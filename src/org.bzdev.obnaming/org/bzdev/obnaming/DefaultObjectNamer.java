package org.bzdev.obnaming;

import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.Collections;
import java.util.Collection;
import java.util.LinkedList;

import java.security.AccessController;
import java.security.PrivilegedAction;

//@exbundle org.bzdev.obnaming.lpack.Obnaming

/**
 * Default implementation of an object namer.
 * The default implementation is a bare-bones implementation
 * suitable for simple applications.
 * The type parameter TO provides the type of a subclass of
 * DefaultNamedObject that is the common superclass of all named objects
 * recognized by this object namer.  Unlike object namers generated by
 * the annotation ObjectNamer, this object namer implicitly extends
 * java.lang.Object and has no other superclass.
 * <P>
 * The default implementation avoids the need to use an annotation
 * processor to generate code.
 * <P>
 * As an example, to create an object namer, a named object, and
 * a factory for the named object, one would define the following
 * classes:
 * <blockquote><code><pre>
 *  abstract public class OurNamedObject
 *        extends DefaultNamedObject&lt;OurNamedObject&gt;
 *  {
 *       ...
 *       protected OurNamedObject(OurObjectNamer namer,
 *                                String name,
 *                                boolean intern)
 *       {
 *          super(namer, name, intern);
 *       }
 *  }
 *
 *  public class OurObjectNamer
 *       extends DefaultObjectNamer&lt;OurNamedObject&gt;
 *  {
 *       ...
 *       public OurObjectNamer() {
 *           super(OurNamedObject.class);
 *       }
 *  }
 *
 *  abstract public class OurObjectFactory<OBJ extends OurNamedObject>
 *       extends DefaultNOFactory&lt;OurObjectNamer,OurNamedObject,OBJ&gt;
 *  {
 *       ...
 *       protected OurObjectFactory(OurObjectNamer namer) {
 *          super(namer);
 *       }
 *  }
 * </pre></code></blockquote>
 * Additional code (indicated by an ellipsis) is, of course, necessary
 * to do anything useful.
 */
public class DefaultObjectNamer<TO extends DefaultNamedObject<TO>>
    implements ObjectNamerOps<TO>
{
    static String errorMsg(String key, Object... args) {
	return ObnamingErrorMsg.errorMsg(key, args);
    }


    Map<Class,Map<String,TO>> maps = 
        new HashMap<Class,Map<String,TO>>();

    private Map<String,TO> createMap(Class<?>clazz) {
	Map<String,TO> result = new HashMap<String,TO>();
	if (clazz != null) {
	    for (Class cls: maps.keySet()) {
		if (clazz.isAssignableFrom(cls)) {
		    result.putAll(maps.get(cls));
		}
	    }
	}
	return result;
    }

    private Class<TO> baseClass;

    public Class<TO> getNamedObjectClass() {return baseClass;}

    /**
     * Constructor.
     * For technical reasons related to type erasure, an argument providing
     * the same class as the one used for the type parameter TO must be
     * passed to the constructor explicitly.
     * @param clazz the class of the type named by the type parameter TO
     */
    public DefaultObjectNamer(Class<TO> clazz) {
	baseClass = clazz;
	maps.put(clazz, createMap(null));
    }

    // used by NamedObject
    @SuppressWarnings("unchecked")
	boolean addObject(String name, DefaultNamedObject<TO> object) {
	Class<?> subclass = object.getClass();
	if (!(baseClass.isAssignableFrom(subclass/*object.getClass()*/))) {
	    throw new IllegalArgumentException
		(errorMsg("notInstance", baseClass.toString()));

	}
	TO obj = (TO) object;

	if (subclass.isInterface() || subclass.isAnnotation()) {
	    throw new IllegalArgumentException(errorMsg("classExpected"));
	}

	while (subclass.isAnonymousClass()) {
	    // if we allow subclass to be an anonymous class, we
	    // could end up with a lot of hash tables that hold only
	    // a single element. It is possible to create multiple
	    // instances of member and local classes, so we don't
	    // skip those.
	    subclass = subclass.getSuperclass();
	}
        if (!maps.containsKey(subclass)) maps.put(subclass,
						  createMap(subclass));
        
        Map<String,TO> map = maps.get(baseClass);
        Map<String,TO> map2 = maps.get(subclass);

        if (map.containsKey(name)) {
            return false;

        }
        map.put(name, obj);
	while (subclass != baseClass) {
	    if (map2 != null) map2.put(name, obj);
	    subclass = subclass.getSuperclass();
	    map2 = maps.get(subclass);
	}
        return true;
    }

    boolean removeObject(DefaultNamedObject<TO> object)
    {
	if (!object.isInterned()) {
	    return false;
	}

	Class<?> subclass = object.getClass();
	if (!baseClass.isAssignableFrom(subclass)) {
	    String scn = subclass.getName();
	    String bcs = baseClass.getName();
	    throw new IllegalArgumentException
		(errorMsg("notInheritedFrom", scn , bcs));
	}
	String name = object.getName();

        Map<String,TO> map = maps.get(baseClass);
        if (!map.containsKey(name)) {
            return false;
        }
        Map<String,TO> map2 = maps.get(subclass);
        map.remove(name);
	while (subclass != baseClass) {
	    if (map2 != null)  map2.remove(name);
	    subclass = subclass.getSuperclass();
	    map2 = maps.get(subclass);
	}
        return true;
    }

    LinkedList<ObjectNamerOps<TO>> altList =
	new LinkedList<ObjectNamerOps<TO>>();

    /**
     * Add an alternative object namer for use by getObject methods.
     * @param altNamer the alternative object namer
     */
    public final void addObjectNamer(ObjectNamerOps<TO> altNamer) {
	if (altNamer == this || altList.contains(altNamer)) return;
	if (!altNamer.checkAltList(this))
	    throw new IllegalArgumentException
		(errorMsg("altNameLoop"));
	altList.add(altNamer);
    }

     /**
      * Determine if the argument is equal to this object namer or
      * a member of this object namer's object-namer list. This test
      * is recursive. It is specified in this interface for technical
      * reasons, and is not intended to be called otherwise. It is
      * called by addObjectNamer to ensure that a depth-first search
      * will terminate.
      * @param altNamer the object namer to test
      * @return true if he argument is equal to this object namer or
      * a member of this object namer's object-namer list, tested
      * recursively; false otherwise
      */
    public boolean checkAltList(ObjectNamerOps<TO> altNamer) {
	if (altNamer == this) return false;
	for (ObjectNamerOps<TO> alt: altList) {
	    if (!alt.checkAltList(altNamer)) return false;
	}
	return true;
    }

    /**
     * Get an object from the object namer's tables.
     * @param name the name of the object
     * @return the object corresponding to the name provided
     */
    public TO getObject(String name) {
        Map<String,TO> map = maps.get(baseClass);
	TO result = map.get(name);
	if (result == null) {
	    for (ObjectNamerOps<TO> altNamer: altList) {
		result = altNamer.getObject(name);
		if (result != null) break;
	    }
	}
	return result;
    }

    /**
     * Get all the object names from a object namer's tables.
     * @return a set containing the names of all objects interned in
     *         the object namer's tables
     */
    public Set<String> getObjectNames() {
        return
	    Collections.unmodifiableSet(maps.get(baseClass).keySet());
    }

    /**
     * Get a set of object names from a object namer's tables.
     * The objects are those for which either their classes or
     * one of their superclasses match the class passed as an argument.
     * @param clazz the class of the objects to get.
     * @return a set containing the names of all objects interned in
     *         the object namer's tables such that the class of that object
     *         or the class of a subclass of that object matches the clazz
     *         argument
     */
    public Set<String> getObjectNames(Class<?> clazz) {
        Map<String,TO> map = maps.get(clazz);
        if (map == null) {
	    if (baseClass.isAssignableFrom(clazz)) {
		map = createMap(clazz);
		maps.put(clazz, map);
	    } else {
		return Collections.emptySet();
	    }
        }
        return Collections.unmodifiableSet(map.keySet());
    }

    /**
     * Get a named object with a particular name, provided that
     * the object is a subclass of a specific class.
     * @param name the name of the object
     * @param clazz the class of the object
     * @return the object or null if the object cannot be found
     */
    @SuppressWarnings("unchecked")
    public<T> T getObject(String name, Class<T> clazz) {
        Map<String,TO> map = maps.get(baseClass);
	TO result = map.get(name);
	if (result != null &&
	    !(clazz.isAssignableFrom(result.getClass()))) {
	    result = null;
	}
	if (result == null) {
	    for (ObjectNamerOps<TO> altNamer: altList) {
		T altResult = altNamer.getObject(name, clazz);
		if (altResult != null) {
		    return altResult;
		}
	    }
	}
	return (T)result;
    }

    /**
     * Get a collection of all the interned named objects associated
     * with an object namer.
     * @return an unmodifiable collection of the objects interned in
     *         the object namer's tables.
     */
    public Collection<TO> getObjects() {
	Map<String,TO> map = maps.get(baseClass);
	return Collections.unmodifiableCollection(map.values());
    }


    /**
     * Get a collection of objects with a class constraint from a
     * object namer's tables.
     * The objects are those for which either their classes or
     * one of their superclasses match the class passed as an argument.
     * @param clazz the class of the objects to get.
     * @return an unmodifiable collection containing all interned
     *         objects whose class or one of its superclasses matches
     *         the class clazz passed as the method's argument
     */
    @SuppressWarnings("unchecked")
    public <T> Collection<T> getObjects(Class<T> clazz) {
        Map<String,TO> map = maps.get(clazz);
        if (map == null) {
	    if (baseClass.isAssignableFrom(clazz)) {
		map = createMap(clazz);
		maps.put(clazz, map);
	    } else {
		return Collections.emptyList();
	    }
        }
        return Collections.unmodifiableCollection((Collection<T>)map.values());
    }

    /**
     * Get a collection of objects with a class constraint, expressed as a
     *  class name, from a object namer's tables.
     * The objects are those for which either their classes or
     * one of their superclasses match the class passed as an argument.
     * <P>
     * Note: this method is provided because script engines do not
     * provide a standard way of denoting a Java class (the class not
     * an instance of it).  The collection it returns is a collection
     * of the common named object type.  Except for scripting languages
     * that do not provide compile-time type checking, one should nearly
     * always use {@link #getObjects(Class)}.
     * @param className the fully qualified class name of the objects to get.
     * @return an unmodifiable collection containing all interned
     *         objects whose class or one of its superclasses matches
     *         the class clazz passed as the method's argument; an
     *         empty (and unmodifiable) collection if no objects can be found
     */
    @SuppressWarnings("unchecked")
     public Collection<TO> getObjects(String className) {
	try {
	    ClassLoader scl = AccessController.doPrivileged
		(new PrivilegedAction<ClassLoader>() {
		    public ClassLoader run() {
			return ClassLoader.getSystemClassLoader();
		    }
		});
	     Class clazz = scl.loadClass(className);
	     return  getObjects(clazz);
	} catch (ClassNotFoundException e1) {
	    return java.util.Collections.emptyList();
	}
    }


    /**
     * Determine if the configureFactory method is supported.
     * The default implementation always returns false, and subclasses
     * that implement configureFactory should override this method.
     * @return true if configure() is supported; false otherwise
     */
    public boolean configureFactorySupported() {
	return false;
    }

    /**
     * Configure a factory.
     * This is an optional operation. The default behavior is that
     * the object namer handles the operation and throws an
     * UnsupportedOperationException if it cannot.  The default behavior
     * is to throw an UnsupportedOperationException.  A subclass should
     * override this method and the method configureFactorySupported if
     * the subclass provides support for scripting and the ability to
     * configure objects in this way.
     * @param factory the factory to configure
     * @param scriptObject an object in a scripting language
     *        representing a specification for how this factory
     *        should be configured
     * @exception UnsupportedOperationException the factory
     *            cannot be configured using a script object
     * @exception IllegalArgumentException the scriptObject is
     *            ill formed
     */
    public void configureFactory(NamedObjectFactory factory,
				 Object scriptObject)
	throws UnsupportedOperationException
    {
	throw new UnsupportedOperationException();
    }

     /**
      * Create a factory and store it using a scripting-language variable..
      * This method just throws an UnsupportedOperationException as
      * this class is not an instance of ScriptingContext.
      * in case a user of this method tries to assign the value it returns.
      * @param varName the name of a scripting-language variable
      * @param packageName the name of the package (null or an empty
      *        string for the unnamed package)
      * @param className the  class name of a factory, excluding the
      *        package name
      * @return the factory that was created
      * @exception IllegalArgumentException the factory is not listed in
      *            a META-INF/services/org.bzdev.NamedObjectFactory resource
      *            or the class name does not refer to subclass of
      *            NamedObjectFactory
      * @exception UnsupportedOperationException this object namer does not
      *            support scripting;
      * @exception IllegalArgumentException the factory is not listed in
      *            a META-INF/services/org.bzdev.NamedObjectFactory resource
      *            or the class name does not refer to subclass of
      *            NamedObjectFactory
      */
    public NamedObjectFactory createFactory(String varName,
					    String packageName,
					    String className)
	 throws UnsupportedOperationException, IllegalArgumentException
    {
	throw new UnsupportedOperationException();
    }

     /**
      * Create a factory.
      * The factory must have a single-argument constructor that takes
      * the class name as its argument
      * @param className the fully-qualified class name of a factory.
      * @exception IllegalArgumentException the factory is not listed in
      *            a META-INF/services/org.bzdev.NamedObjectFactory resource
      *            or the class name does not refer to subclass of
      *            NamedObjectFactory
      */
    public NamedObjectFactory createFactory(String className)
	 throws IllegalArgumentException
    {
	return NamedObjectFactory.newInstance(this, className);
    }
    /**
     * Create a factory given a class.
     * The factory must have a single-argument constructor that takes
     * its object namer as its argument.
     * @param clazz the factory's class.
     * @exception IllegalArgumentException the factory is not listed in
     *            a META-INF/services/org.bzdev.NamedObjectFactory resource
     *            or the class name does not refer to subclass of
     *            NamedObjectFactory
     */
    public NamedObjectFactory createFactory(Class clazz)
	 throws IllegalArgumentException
    {
	return NamedObjectFactory.newInstance(this, clazz);
    }
}

//  LocalWords:  exbundle namer DefaultNamedObject superclass namers
//  LocalWords:  ObjectNamer blockquote pre OurNamedObject lt boolean
//  LocalWords:  OurObjectNamer DefaultObjectNamer OurObjectFactory
//  LocalWords:  DefaultNOFactory clazz NamedObject getClass altNamer
//  LocalWords:  notInstance classExpected notInheritedFrom getObject
//  LocalWords:  altNameLoop namer's addObjectNamer superclasses
//  LocalWords:  configureFactory UnsupportedOperationException
//  LocalWords:  configureFactorySupported scriptObject className
//  LocalWords:  IllegalArgumentException NamedObjectFactory
