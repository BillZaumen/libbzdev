package org.bzdev.geom;
import java.awt.geom.AffineTransform;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.util.List;
import java.util.function.Predicate;
import org.bzdev.math.RealValuedFunctOps;
import org.bzdev.math.VectorOps;

//@exbundle org.bzdev.geom.lpack.Geom

/**
 * Utility class to create various 2D paths. This class consists of
 * static methods.
 * <P>
 * The methods named createArc will generate either a circular arc or
 * a combination of a circular arc and a straight-line segment,
 * depending on the arguments.  Straight-line segments may appear in a
 * path generated by a createArc method when the arguments delimit the
 * path by providing starting and ending points and the curve's
 * tangents at these points.  All of these methods are provided in
 * pairs, with one of the pair containing a final argument whose name
 * is <CODE>maxDelta</CODE>.  The smaller <CODE>maxDelta</CODE> is,
 * the better the approximation to a circular arc will be. The default
 * value of <CODE>maxDelta</CODE> is &pi;/9 radians (20 degrees)
 * and the maximum is 2&pi;/3 (120 degrees) for reasons specific to
 * the implementation.
 * <P>
 * With the default value of <CODE>maxDelta</CODE> and a unit circle,
 * the mean of the distance of points on an arc from the arc's center
 * is 1.7&times;10<sup>-8</sup>, the standard deviation is
 * 1.2&times;10<sup>-8</sup>, and the worst case deviation from 1 is
 * 3.27&times;<sup>-8</sup>. The mean value of the curvature differs
 * from the expected value of 1 by -1.288&times;10<sup>-8</sup> and
 * the standard deviation is 1.7&times;<sup>-5</sup>.  By contrast,
 * for a unit circle created using the class
 * <CODE>java.awt.geom.Ellipse2D.Double</CODE>, the mean of the
 * distance of points on an arc from the arc's center is 0.00015, the
 * standard deviation is 0.0001, and the worst case deviation from 1
 * is 0.00027. The mean value of the curvature for this Ellipse2D case
 * differs from the expected value of 1 by -0.0001 with a standard
 * deviation of 0.0067. For general use in computer graphics, the
 * Ellipse2D class is more than adequate for creating a circle. On
 * the other hand, for some 3D-printing applications, the deviation
 * from the ideal value may be too high. In a physics (classical
 * mechanics) application, the acceleration normal to the path for
 * an object moving along the path is proportional to the curvature,
 * and using the Ellipse2D class would generate an error of just under
 * 1 percent.
 */
public class Paths2D {

    // just static
    private Paths2D() {}

    static String errorMsg(String key, Object... args) {
	return GeomErrorMsg.errorMsg(key, args);
    }

    // This method is private because of a precondition: that
    // (x1, y1) and (x2, y2) lie along a circle whose center
    // is (xc, yc).
    private static void createArcAux(double xc, double yc,
				     double x1, double y1,
				     double x4, double y4,
				     double[] coords)
	throws IllegalArgumentException
    {
	// Algorithm from "An Improved Algorithm for the
	// Approximation of a Cubic Bezier Curve and its
	// Application for Approximating Quadratic Bezier
	// Curve", Aleksas Riskus and Giedrfia Liekus,
	// Informatyion Technology and Control, 2013, T.42, Nr 4,
	// pages 303--308
	// https://pdfs.semanticscholar.org/f99c/55f7f3a15c169e5be425df530fc96e765c9b.pdf
	// This includes a correction to a previous publication.
	double ax = x1 - xc;
	double ay = y1 - yc;
	double bx = x4 - xc;
	double by = y4 - yc;
	double q1 = ax*ax + ay*ay;
	double q2 = q1 + ax*bx + ay * by;
	double tmp = (ax*by - ay*bx);
	if (tmp == 0.0) {
	    String msg = errorMsg("colinear", xc, yc, x1, y1, x4, y4);
	    throw new IllegalArgumentException("colinear");
	}
	double k2 = (4.0/3.0)*(Math.sqrt(2*q1*q2) - q2)/tmp;

	coords[0] = /*xc + ax*/ x1 - k2*ay;
	coords[1] = /*yc + ay*/ y1 + k2*ax;
	coords[2] = /*xc + bx*/ x4 + k2*by;
	coords[3] = /*yc + by*/ y4 - k2*bx;
	coords[4] = x4;
	coords[5] = y4;
    }

    /**
     * Create a circular arc given an angular extent
     * @param xc the X coordinate of the center of the arc's circle
     * @param yc the Y coordinate of the center of the arc's circle
     * @param x1 the X coordinate of a point on the arc
     * @param y1 the Y coordinate of a point on the arc
     * @param theta the angular extent of the arc in radians, where
     *        positive values represent a rotation from the positive
     *        X axis towards the positive Y axis
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     */
    public static Path2D createArc(double xc, double yc,
				   double x1, double y1,
				   double theta)
	throws IllegalArgumentException
    {
	return createArc(xc, yc, x1, y1, theta, DEFAULT_MAX_DELTA);
    }

    /**
     * The constant 2&pi;/3.
     */
    public static final double TWO_THIRDS_PI = 2*Math.PI/3;
    static final double PI2 = 2.0*Math.PI;

    /**
     * Create a circular arc given an angular extent and a limit on
     * the angular extent of cubic B&eacute;zier curve segments.
     * @param xc the X coordinate of the center of the arc's circle
     * @param yc the Y coordinate of the center of the arc's circle
     * @param x1 the X coordinate of a point on the arc
     * @param y1 the Y coordinate of a point on the arc
     * @param theta the angular extent of the arc in radians, where
     *        positive values represent a rotation from the positive
     *        X axis towards the positive Y axis
     * @param maxDelta the maximum angular extent for each cubic B&eacute;zier
     *        segment making up the arc, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     */
    public static Path2D createArc(double xc, double yc,
				   double x1, double y1,
				   double theta,
				   double maxDelta)
	throws IllegalArgumentException
    {
	if (maxDelta <= 0.0 || maxDelta > TWO_THIRDS_PI) {
	    throw new IllegalArgumentException(errorMsg("maxDelta", maxDelta));
	}
	Path2D path = new Path2D.Double();
	path.moveTo(x1, y1);
	if ((xc == x1 && yc == y1) || theta == 0.0) {
	    return path;
	}
	boolean twoPIMode = (theta == PI2);
	long nt = Math.round(theta / PI2);
	if (Math.abs((nt*PI2 - theta)/theta) < 1.e-12) {
	    // If we are within an even multiple of 2 pi to
	    // within floating-point accuracy, assume an angle
	    // that is a multiple of 2 pi, so that the final point
	    // exactly matches the initial point
	    twoPIMode = true;
	}

	double[] coords = new double[6];
	int n = (int)Math.round(Math.ceil(Math.abs(theta)/maxDelta));
	double delta = theta/n;
	AffineTransform af = AffineTransform.getRotateInstance(delta, xc, yc);
	coords[4] = x1;
	coords[5] = y1;
	for (int i = 0; i < n; i++) {
	    if (twoPIMode && i == n-1) {
		// For a 2 pi arc, we should go back to the
		// starting point exactly.  This fixes up that
		// particular case.
		coords[0] = x1;
		coords[1] = y1;
	    } else {
		af.transform(coords, 4, coords, 0, 1);
	    }
	    createArcAux(xc, yc, coords[4], coords[5],
			 coords[0], coords[1], coords);
	    path.curveTo(coords[0], coords[1], coords[2], coords[3],
			 coords[4], coords[5]);
	}
	return path;
    }




    /**
     * Create an arc specifying a radius, a path whose final point
     * and final tangent match the start of the arc, and the angular
     * extent of the arc.
     * @param spath the path before the start of the arc
     * @param radius the radius of the arc
     * @param counterClockwise true if the arc turns in the same angular
     *        direction as a rotation from the positive X axis to the
     *        positive Y axis; false if the arc turns in the same angular
     *        direction as a rotation from the positive X axis to the
     *        negative Y axis
     * @param theta the angular extent of the arc (if negative, the arc
     *        will form a cusp with the specified path)
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D spath, double radius,
				   boolean counterClockwise, double theta)
	throws IllegalArgumentException, NullPointerException

    {
	return createArc(spath, radius, counterClockwise, theta,
			 DEFAULT_MAX_DELTA);
    }

    /**
     * Create an arc specifying a radius, a path whose final point
     * and final tangent match the start of the arc, and the angular
     * extent of the arc.
     * @param spath the path before the start of the arc
     * @param radius the radius of the arc
     * @param counterClockwise true if the arc turns in the same angular
     *        direction as a rotation from the positive X axis to the
     *        positive Y axis; false if the arc turns in the same angular
     *        direction as a rotation from the positive X axis to the
     *        negative Y axis
     * @param theta the angular extent of the arc (if negative, the arc
     *        will form a cusp with the specified path)
     * @param maxDelta the maximum angular extent for each cubic B&eacute;zier
     *        segment making up the arc, with values in the range
     *        (0.0, 2&pi;/3]
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D spath, double radius,
				   boolean counterClockwise, double theta,
				   double maxDelta)
	throws IllegalArgumentException, NullPointerException

    {
	// do later.
	double[] array = new double[2];
	Path2DInfo.getNormal(spath, Path2DInfo.Location.END, array, 0);
	Point2D p = spath.getCurrentPoint();
	double x = p.getX();
	double y = p.getY();
	double xc, yc;
	if (counterClockwise) {
	    xc = x + radius*array[0];
	    yc = y + radius*array[1];
	    return createArc(xc, yc, x, y, theta, maxDelta);
	} else {
	    xc = x - radius*array[0];
	    yc = y - radius*array[1];
	    return createArc(xc, yc, x, y, -theta, maxDelta);
	}
    }

    /**
     * Create a circular arc given a starting path and a final point.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param path a path whose current point is the initial point of
     *        the arc and whose last tangent vector is the initial tangent
     *        vector for the arc
     * @param point the final point for the arc
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D path, Point2D point)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(path, point, DEFAULT_MAX_DELTA);
    }

    /**
     * Create a circular arc given a starting path, a final point, and
     * an angular limit.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param path a path whose current point is the initial point of
     *        the arc and whose last tangent vector is the initial tangent
     *        vector for the arc
     * @param point the final point for the arc
     * @param theta the angular limit in radians for each B&eacute;zier
     *        curve segment making up the arc, measured from the center
     *        of the circle the arc follows.
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D path, Point2D point, double theta)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(path, point.getX(), point.getY(), theta);
    }

    /**
     * Create a circular arc given a starting path and the X and Y
     * coordinates of a final point.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param path a path whose current point is the initial point of
     *        the arc and whose last tangent vector is the initial tangent
     *        vector for the arc
     * @param x X coordinate for the final point for the circular arc
     * @param y the Y coordinate for final point for the circular arc
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D path, double x, double y)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(path, x, y, DEFAULT_MAX_DELTA);
    }


    /**
     * Create a circular arc given a starting path, the X and Y
     * coordinates of a final point, and an angular limit.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param path a path whose current point is the initial point of
     *        the arc and whose last tangent vector is the initial tangent
     *        vector for the arc
     * @param x X coordinate for the final point for the circular arc
     * @param y the Y coordinate for final point for the circular arc
     * @param maxDelta the angular limit in radians for each B&eacute;zier
     *        curve segment making up the arc, measured from the center
     *        of the circle the arc follows, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the arc
     * @exception IllegalArgumentException the path does not have a tangent
     *            at the path's end
     * @exception NullPointerException the path argument was null
     */
    public static Path2D createArc(Path2D path, double x, double y,
				   double maxDelta)
	throws IllegalArgumentException, NullPointerException
    {
	if (path == null) {
	    throw new NullPointerException(errorMsg("nullArg", 1));
	}
	double[] array = new double[2];
	if (!Path2DInfo.getTangent(path, Path2DInfo.Location.END, array, 0)) {
	    throw new IllegalArgumentException(errorMsg("noTangent", 1));
	}
	Point2D point = path.getCurrentPoint();

	return createArc(point.getX(), point.getY(), array, 0, x, y,
			 maxDelta);
    }

    /**
     * Create a circular arc given a starting point, a tangent vector,
     * and a final point.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param x1 X coordinate for the starting point for the circular arc
     * @param y1 the Y coordinate for starting point for the circular arc
     * @param tangent an array containing the tangent vector
     * @param offset an offset into the tangent array such that
     *        tangent[offset] contains the X coordinate for the
     *        tangent vector and tangent[offset+1] contains the Y
     *        coordinate for the tangent vector
     * @param x2 X coordinate for the final point for the circular arc
     * @param y2 the Y coordinate for final point for the circular arc
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException an array argument was null
     */
    public static Path2D createArc(double x1, double y1,
				   double[] tangent, int offset,
				   double x2, double y2)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(x1, y1, tangent, offset, x2, y2, DEFAULT_MAX_DELTA);
    }

    /**
     * Create a circular arc given a starting point, a tangent vector,
     * a final point, and an angular limit.
     * The arc starts parallel to the tangent vector and in the tangent
     * vector's direction.
     * @param x1 X coordinate for the starting point for the circular arc
     * @param y1 the Y coordinate for starting point for the circular arc
     * @param tangent an array containing the tangent vector
     * @param offset an offset into the tangent array such that
     *        tangent[offset] contains the X coordinate for the
     *        tangent vector and tangent[offset+1] contains the Y
     *        coordinate for the tangent vector
     * @param x2 X coordinate for the final point for the circular arc
     * @param y2 the Y coordinate for final point for the circular arc
     * @param maxDelta the angular limit in radians for each B&eacute;zier
     *        curve segment making up the arc, measured from the center
     *        of the circle the arc follows, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException an array argument was null
     */
    public static Path2D createArc(double x1, double y1,
				   double[] tangent, int offset,
				   double x2, double y2,
				   double maxDelta)
    {
	if (maxDelta <= 0.0 || maxDelta > TWO_THIRDS_PI) {
	    throw new IllegalArgumentException(errorMsg("maxDelta", maxDelta));
	}
	if (tangent == null) {
	    throw new NullPointerException(errorMsg("nullTangent"));
	}
	if (tangent.length < 2) {
	    throw new IllegalArgumentException(errorMsg("tangentLength", 3));

	}
	if (offset < 0 || offset > tangent.length-2) {
	    throw new IllegalArgumentException
		(errorMsg("tangentOffset", 4, offset));
	}
	double t1x = tangent[offset];
	double t1y = tangent[offset+1];
	double tmp = Math.sqrt(t1x*t1x + t1y*t1y);
	t1x /= tmp;
	t1y /= tmp;
	double n1x = -t1y;
	double n1y = t1x;
	double x1a = x1 + n1x;
	double y1a = y1 + n1y;
	double chordx = (x2 - x1);
	double chordy = (y2 - y1);
	tmp = Math.sqrt(chordx*chordx + chordy*chordy);
	double theta;
	double xc, yc;
	double [] coords = new double[6];
	if (Math.abs(n1x*chordy - n1y*chordx)/tmp < 1.e-10) {
	    // the center is along the chord.
	    xc  = x1 + chordx/2;
	    yc = y1 + chordy/2;
	    if ((t1x*chordy - chordx*t1y) > 0.0) {
		theta = Math.PI;
	    } else {
		theta = -Math.PI;
	    }
	} else {
	    double pt1x = x1 + chordx/2;
	    double pt1y = y1 + chordy/2;
	    chordx /= tmp;
	    chordy /= tmp;
	    double chordNx = -chordy;
	    double chordNy = chordx;

	    double pt2x = pt1x + chordNx;
	    double pt2y = pt1y + chordNy;
	    boolean status =
		Path2DInfo.getLineIntersectionUVXY(x1, y1, x1a, y1a,
						   pt1x, pt1y, pt2x, pt2y,
						   coords, 0);
	    if (status == false) {
		// co-linear case: return a straight line.
		Path2D lpath = new Path2D.Double();
		lpath.moveTo(x1, y1);
		lpath.lineTo(x2, y2);
		return lpath;
	    }
	    double u = coords[0];
	    double v = coords[1];
	    xc = coords[2];
	    yc = coords[3];
	    if (u > 0) {
		n1x = -n1x;
		n1y = -n1y;
	    } else {
		// t1x = -t1x;
		// t1y = -t1y;
	    }
	    double xn2 = x2 - xc;
	    double yn2 = y2 - yc;
	    theta = Math.atan2(t1x*xn2 + t1y*yn2,
			       n1x*xn2 + n1y*yn2);
	    if  (theta < 0) theta += 2*Math.PI;
	    if (u < 0.0) theta = -theta;
	}
	Path2D path = new Path2D.Double();
	path.moveTo(x1, y1);

	int n = (int)Math.round(Math.ceil(Math.abs(theta)/maxDelta));
	double delta = theta/n;
	AffineTransform af = AffineTransform.getRotateInstance(delta, xc, yc);
	coords[4] = x1;

	coords[5] = y1;
	if (n > 1) {
	    for (int i = 1; i < n; i++) {
		af.transform(coords, 4, coords, 0, 1);
		createArcAux(xc, yc, coords[4], coords[5],
			     coords[0], coords[1], coords);
		path.curveTo(coords[0], coords[1], coords[2], coords[3],
			     coords[4], coords[5]);
	    }
	} else {
	    coords[4] = x1;
	    coords[5] = y1;
	}
	af.transform(coords, 4, coords, 0, 1);
	createArcAux(xc, yc, coords[4], coords[5], coords[0], coords[1],
		     coords);
	// use (x2, y2) so there will be an exact match - i.e., no
	// floating-point errors
	path.curveTo(coords[0], coords[1], coords[2], coords[3],
		     x2, y2);
	return path;
    }

    /**
     * The default maxdelta value (&pi;/9 radians = 20 degrees).
     */
    public static final double DEFAULT_MAX_DELTA = Math.PI/9;


    private static final
	Path2DInfo.UValues uvZero = new Path2DInfo.UValues(0.0);
    private static final
	Path2DInfo.UValues uvOne = new Path2DInfo.UValues(1.0);

    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed, connecting the end of
     * path1 with the start of path2.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * @param path1 the preceding path
     * @param path2 the following path
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException path1 or path2 was null
     */
    public static Path2D createArc(Path2D path1, Path2D path2)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(path1, path2, DEFAULT_MAX_DELTA);
    }
    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed, connecting the end of
     * path1 with the start of path2, and specifying the maximum angular
     * extent of each segment of the circular arc.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * @param path1 the preceding path
     * @param path2 the following path
     * @param maxDelta the angular limit in radians for each B&eacute;zier
     *        curve segment in the arc, measured from the center
     *        of the circle the arc follows, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException path1 or path2 was null
     */
	public static Path2D createArc(Path2D path1, Path2D path2,
				       double maxDelta)
	throws IllegalArgumentException, NullPointerException
    {
	if (path1 == null) {
	    throw new NullPointerException(errorMsg("nullArg", 1));
	}
	if (path2 == null) {
	    throw new NullPointerException(errorMsg("nullArg", 2));
	}
	double[] array = new double[4];
	if (!Path2DInfo.getTangent(path1, Path2DInfo.Location.END, array, 0)) {
	    throw new IllegalArgumentException(errorMsg("noTangent", 1));
	}
	if (!Path2DInfo.getTangent(path2,Path2DInfo.Location.START,array,2)) {
	    throw new IllegalArgumentException(errorMsg("noTangent", 2));
	}
	Point2D point1 = path1.getCurrentPoint();
	Point2D point2 = Path2DInfo.getStart(path2);
	return createArc(point1.getX(), point1.getY(), array, 0,
			 point2.getX(), point2.getY(), array, 2,
			 maxDelta);
    }

    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed, with an array representation
     * for tangent vectors.
     * Both tangent vector's point in the direction of an increasing path
     * parameter with the initial point having a path parameter of 0.0.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * If the arc does not exist, an exception will be thrown.
     * @param x1 the X coordinate of the extended arc's initial point
     * @param y1 the Y coordinate of the extended arc's initial point
     * @param tangent1 an array containing the initial point's tangent vector
     * @param offset1 an offset into tangent1 such that
     *        tangent1[offset1] contains the X component of the tangent
     *        vector and tangent1[offset1+1] contains the X component
     *        of the initial point's tangent vector
     * @param x2 the X coordinate of the extended arc's final point
     * @param y2 the Y coordinate of the extended arc's final point
     * @param tangent2 an array containing the final point's tangent vector
     * @param offset2 an offset into tangent1 such that
     *        tangent2[offset2] contains the X component of the tangent
     *        vector and tangent2[offset2+1] contains the Y component
     *        of the final point's tangent vector
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException an array argument was null
     */
    public static Path2D createArc(double x1, double y1,
				     double[] tangent1, int offset1,
				     double x2, double y2,
				     double[] tangent2, int offset2)
	throws IllegalArgumentException, NullPointerException
    {
	return createArc(x1, y1, tangent1, offset1,
			 x2, y2, tangent2, offset2,
			 DEFAULT_MAX_DELTA);
    }

    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed, with an array representation
     * for tangent vectors, and with a maximum angular extend for each
     * segment of the circular arc.
     * Both tangent vector's point in the direction of an increasing path
     * parameter with the initial point having a path parameter of 0.0.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * If the arc does not exist, an exception will be thrown.
     * @param x1 the X coordinate of the extended arc's initial point
     * @param y1 the Y coordinate of the extended arc's initial point
     * @param tangent1 an array containing the initial point's tangent vector
     * @param offset1 an offset into tangent1 such that
     *        tangent1[offset1] contains the X component of the tangent
     *        vector and tangent1[offset1+1] contains the X component
     *        of the initial point's tangent vector
     * @param x2 the X coordinate of the extended arc's final point
     * @param y2 the Y coordinate of the extended arc's final point
     * @param tangent2 an array containing the final point's tangent vector
     * @param offset2 an offset into tangent1 such that
     *        tangent2[offset2] contains the X component of the tangent
     *        vector and tangent2[offset2+1] contains the Y component
     *        of the final point's tangent vector
     * @param maxDelta the angular limit in radians for each B&eacute;zier
     *        curve segment in the arc, measured from the center
     *        of the circle the arc follows, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     * @exception NullPointerException an array argument was null
     */
    public static Path2D createArc(double x1, double y1,
				   double[] tangent1, int offset1,
				   double x2, double y2,
				   double[] tangent2, int offset2,
				   double maxDelta)
	throws IllegalArgumentException, NullPointerException
    {

	if (tangent1 == null || tangent2 == null) {
	    throw new NullPointerException(errorMsg("nullTangent"));
	}
	if (tangent1.length < 2) {
	    throw new IllegalArgumentException(errorMsg("tangentLength", 3));

	}
	if (tangent2.length < 2) {
	    throw new IllegalArgumentException(errorMsg("tangentLength", 7));
	}
	if (offset1 < 0 || offset1 > tangent1.length-2) {
	    throw new IllegalArgumentException
		(errorMsg("tangentOffset", 4, offset1));
	}
	if (offset2 < 0 || offset2 > tangent2.length-2) {
	    throw new IllegalArgumentException
		(errorMsg("tangentOffset", 8, offset2));
	}

	return createArc(x1, y1, tangent1[offset1], tangent1[offset1+1],
			 x2, y2, tangent2[offset2], tangent2[offset2+1],
			 maxDelta);
    }
				     
    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed.
     * Both tangent vector's point in the direction of an increasing path
     * parameter with the initial point having a path parameter of 0.0.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * If the arc does not exist, an exception will be thrown.
     * @param x1 the X coordinate of the extended arc's initial point
     * @param y1 the Y coordinate of the extended arc's initial point
     * @param t1x the X coordinate of the initial point's tangent vector
     * @param t1y the Y coordinate of the initial point's tangent vector
     * @param x2 the X coordinate of the extended arc's final point
     * @param y2 the Y coordinate of the extended arc's final point
     * @param t2x the X coordinate of the final point's tangent vector
     * @param t2y the Y coordinate of the final point's tangent vector
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     */
    public static Path2D createArc(double x1, double y1,
				     double t1x, double t1y,
				     double x2, double y2,
				     double t2x, double t2y)
	throws IllegalArgumentException
    {
	return createArc(x1, y1, t1x, t1y, x2, y2, t2x, t2y, DEFAULT_MAX_DELTA);
    }
    /**
     * Create a path consisting of a circular arc, extended
     * by a straight line segment if needed, with a bound on the angular
     * extent of each arc segment of the circular arc.
     * Both tangent vector's point in the direction of an increasing path
     * parameter with the initial point having a path parameter of 0.0.
     *<P>
     * The initial and final points, and their tangent vectors, must
     * satisfy one the following constraints for an arc to exist:
     * <UL>
     *   <LI> the initial and final points may be identical, in which
     *        case the arc will exist but will have a length of zero as
     *        it will consist of a single point.
     *   <LI> If the tangent vectors are parallel, the corresponding line
     *        segments must be collinear, and a vector connecting the initial
     *        point to the final point must be parallel to the initial point's
     *        tangent vector.
     *   <LI> If the tangent vectors are antiparallel, the corresponding line
     *        segments must not be collinear.
     *   <LI> Otherwise the tangent lines passing through the initial
     *        and final points are not parallel and will meet at a vertex v.
     *        In this case, the following must be true:
     *        <UL>
     *           <LI> for the directed line segments parallel to the
     *                tangent vectors at the initial and final points,
     *                one segment must point towards the vertex and
     *                the other must point away from the vertex.
     *           <LI> the points on the (extended) arc may include the
     *                directed lines starting at v and passing through
     *                the initial or final points, and the points
     *                between these two directed lines on the side
     *                where the angle between them is smallest.
     *           <LI> the curvature at any point along the extended arc
     *                may be any value in either the range [0, &infin;)
     *                or the range (-&infin;, 0] but not both.
     *        </UL>
     * </UL>
     * If the arc does not exist, an exception will be thrown.
     * @param x1 the X coordinate of the extended arc's initial point
     * @param y1 the Y coordinate of the extended arc's initial point
     * @param t1x the X coordinate of the initial point's tangent vector
     * @param t1y the Y coordinate of the initial point's tangent vector
     * @param x2 the X coordinate of the extended arc's final point
     * @param y2 the Y coordinate of the extended arc's final point
     * @param t2x the X coordinate of the final point's tangent vector
     * @param t2y the Y coordinate of the final point's tangent vector
     * @param maxDelta the angular limit in radians for each B&eacute;zier
     *        curve segment in the arc, measured from the center
     *        of the circle the arc follows, with values in the range
     *        (0.0, 2&pi;/3]
     * @return the path for the extended arc
     * @exception IllegalArgumentException an arc cannot be created
     *            given the parameters
     */
    public static Path2D createArc(double x1, double y1,
				   double t1x, double t1y,
				   double x2, double y2,
				   double t2x, double t2y,
				   double maxDelta)
	throws IllegalArgumentException
    {
	double norm = t1x*t1x + t1y*t1y;
	if (norm != 1.0 && norm != 0.0) {
	    norm = Math.sqrt(norm);
	}
	double tx1 = (norm != 1.0)? t1x/norm: t1x;
	double ty1 = (norm != 1.0)? t1y/norm: t1y;

	norm = t2x*t2x + t2y*t2y;
	if (norm != 1.0 && norm != 0.0) {
	    norm = Math.sqrt(norm);
	}

	double tx2 = (norm != 1.0)? t2x/norm: t2x;
	double ty2 = (norm != 1.0)? t2y/norm: t2y;

	double nx1 = -ty1;
	double ny1 = tx1;
	double nx2 = -ty2;
	double ny2 = tx2;
	double[] array = new double[8];

	double max = Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
	if (max == 0.0) {
	    // the first and last points are identical
	    Path2D path = new Path2D.Double();
	    path.moveTo(x1, y1);
	    return path;
	}
	boolean parallel =
	    !Path2DInfo.getLineIntersectionUVXY(x1, y1, x1 + tx1, y1 + ty1,
						x2, y2, x2 + tx2, y2 + ty2,
						array, 0);
	if (!parallel && (Math.abs(array[0])/max > 1.e10
			  || Math.abs(array[1])/max > 1.e10)) {
	    // Assume 'parallel' is false because of floating-point errors
	    // so set it to true
	    parallel = true;
	}

	if (parallel) {
	    // lines are parallel.
	    if (tx1*tx2 + ty1*ty2 > 0.0) {
		double vx = x2 - x1;
		double vy = y2 - y1;
		double vnorm = Math.sqrt(vx*vx + vy*vy);
		vx /= vnorm;
		vy /= vnorm;
		if (Math.abs(vx*ty1 - vy*tx1) < 1.e-10 &&
		    (vx*tx1 + vy*ty1) > 0.0) {
		    // To within floating point errors, (x2, y2) is
		    // along the line starting at (x1, y1) in the direction
		    // of the tangent vector at (x1, y1)
		    Path2D path = new Path2D.Double();
		    path.moveTo(x1, y1);
		    path.lineTo(x2, y2);
		    return path;
		} else {
		    throw new IllegalArgumentException
			(errorMsg("noArcParallel"));
		}
	    } else {
		double dx = (x2 - x1);
		double dy = (y2 - y1);
		double dnorm = Math.sqrt(dx*dx+dy*dy);
		double dn = dx*nx1 + dy*ny1;
		if (Math.abs(dn/dnorm) < 1.e-10) {
		    // (x2,y2) lies along a line starting at (x1, y1)
		    // and in the (-tx1, -ty1) direction to within
		    // floating-point errors.  We cannot create an
		    // arc without violating the curvature constraint.
		    throw new IllegalArgumentException
			(errorMsg("noArcParallel"));
		}
		double dt = dx*tx1 + dy*ty1;
		double tangent[] = {tx1, ty1};
		if (dt == 0.0) {
		    Path2D result =  createArc(x1, y1, tangent, 0, x2, y2,
					       maxDelta);
		    return result;
		} else if (dt > 0.0) {
		    double xp = x1 + dt*tx1;
		    double yp = y1 + dt*ty1;
		    Path2D result = new Path2D.Double();
		    result.moveTo(x1, y1);
		    result.lineTo(xp, yp);
		    Path2D ptmp = createArc(xp, yp, tangent, 0, x2, y2,
					    maxDelta);
		    result.append(ptmp, true);
		    return result;
		} else {
		    double xp = x2 - dt*tx1;
		    double yp = y2 - dt*ty1;
		    Path2D result = createArc(x1, y1, tangent, 0, xp, yp,
					      maxDelta);
		    result.lineTo(x2, y2);
		    return result;
		}
	    }
	}

	double u = array[0];
	double v = array[1];
	if (Math.abs(u)/max < 1.e-10 || Math.abs(v)/max < 1.e-10) {
	    //degenerate case: The vertex is at an end point.
	    Path2D path = new Path2D.Double();
	    path.moveTo(x1, y1);
	    path.lineTo(x2, y2);
	    return path;
	}
	double xv = array[2];
	double yv = array[3];

	double d1 = Math.sqrt((xv-x1)*(xv-x1) + (yv-y1)*(yv-y1));
	double d2 = Math.sqrt((xv-x2)*(xv-x2) + (yv-y2)*(yv-y2));

	double xp;
	double yp;
	array[0] = tx1;
	array[1] = ty1;
	if (u > 0 && v < 0) {
	    if (Math.abs(d1-d2)/max < 1.e-10) {
		return createArc(x1, y1, array, 0, x2, y2, maxDelta);
	    } else if (d1 < d2) {
		xp = xv + tx2*d1;
		yp = yv + ty2*d1;
		Path2D path = createArc(x1, y1, array, 0, xp, yp, maxDelta);
		path.lineTo(x2, y2);
		return path;
	    } else {
		xp = xv - tx1*d2;
		yp = yv - ty1*d2;
		Path2D path = new Path2D.Double();
		path.moveTo(x1, y1);
		path.lineTo(xp, yp);
		Path2D path2 = createArc(xp, yp, array, 0, x2, y2, maxDelta);
		path.append(path2, true);
		return path;
	    }
	} else if (u < 0 && v > 0) {
	    if (Math.abs(d1-d2)/max < 1.e-10) {
		return createArc(x1, y1, array, 0, x2, y2, maxDelta);
	    } else if (d1 < d2) {
		xp = xv + tx1*d2;
		yp = yv + ty1*d2;
		Path2D path = new Path2D.Double();
		path.moveTo(x1, y1);
		path.lineTo(xp, yp);
		Path2D path2 = createArc(xp, yp, array, 0, x2, y2, maxDelta);
		path.append(path2, true);
		return path;
	    } else {
		xp = xv - tx2*d1;
		yp = yv - ty2*d1;
		Path2D path = createArc(x1, y1, array, 0, xp, yp, maxDelta);
		path.lineTo(x2, y2);
		return path;
	    }
	} else /* (u > 0 && v > 0) || (u < 0 && v < 0) */ {
	    throw new IllegalArgumentException(errorMsg("noArcPossible"));
	}
    }

    /**
     * Apply an affine transformation to a path.
     * @param path the path to transform
     * @param at the affine transform to apply to a path; null for the
     *        identity transformation
     * @return the transformed path
     */
    public static Path2D transformPath(Path2D path, AffineTransform at) {
	List<SplinePathBuilder.CPoint> list
	    = Path2DInfo.getCPoints(path);
	SplinePathBuilder.CPoint[] array =
	    new SplinePathBuilder.CPoint[list.size()];
	array = list.toArray(array);
	AbstractSplinePathBuilder sb = (path instanceof BasicSplinePath2D)?
	    new BasicSplinePathBuilder(): new SplinePathBuilder();
	AbstractSplinePathBuilder.modifyCPoints(array, false, at);
	SplinePathBuilder.WindingRule windingRule =
	    (path.getWindingRule() == Path2D.WIND_EVEN_ODD)?
	    SplinePathBuilder.WindingRule.WIND_EVEN_ODD:
	    SplinePathBuilder.WindingRule.WIND_NON_ZERO;
	sb.initPath(windingRule, array);
	return sb.getPath();
    }

    /**
     * Reverse a path.
     * For a path to be reversible, each {@link PathIterator#SEG_CLOSE}
     * segment that does not end a path must be followed by
     * a {@link PathIterator#SEG_MOVETO} segment.
     * <P>
     * Reversing a path can be useful when a series of closed paths will be
     * appended to represent a shape and the winding rule
     * {@link PathIterator#WIND_NON_ZERO} is used to determine the inside
     * and outside boundaries of the shape.
     * @param path the path to reverse
     * @return the reversed path
     * @exception IllegalArgumentException the path cannot be reversed
     */
    public static Path2D reverse(Path2D path) throws IllegalArgumentException {
	List<SplinePathBuilder.CPoint> list
	    = Path2DInfo.getCPoints(path);
	SplinePathBuilder.CPoint[] array =
	    new SplinePathBuilder.CPoint[list.size()];
	array = list.toArray(array);
	AbstractSplinePathBuilder sb = (path instanceof BasicSplinePath2D)?
	    new BasicSplinePathBuilder(): new SplinePathBuilder();
	AbstractSplinePathBuilder.modifyCPoints(array, true, null);
	SplinePathBuilder.WindingRule windingRule =
	    (path.getWindingRule() == Path2D.WIND_EVEN_ODD)?
	    SplinePathBuilder.WindingRule.WIND_EVEN_ODD:
	    SplinePathBuilder.WindingRule.WIND_NON_ZERO;
	sb.initPath(windingRule, array);
	return sb.getPath();
    }

    private static double ANGLE_LIMIT = 0.001; // radians

    private static class ConditionHandler {
	double x0 = 0.0, y0 = 0.0;
	double[] tcoords = new double[6];

	private static final double UVALS[] = {
	    0.0, 0.25, 0.5, 0.75, 1.0
	};

	void setup(double[] coords) {
	    x0 = coords[0];
	    y0 = coords[1];
	    System.arraycopy(coords, 2, tcoords, 0, coords.length - 2);
	}

	private Predicate<double[]> condition = (coords) -> {
	    setup(coords);

	    int type = (coords.length == 8)? PathIterator.SEG_QUADTO:
	    PathIterator.SEG_CUBICTO;

	    double kappa1 = Path2DInfo.curvature(0.0, x0, y0, type, tcoords);
	    double kappa2 = Path2DInfo.curvature(1.0, x0, y0, type, tcoords);

	    if ((kappa1 < 0 && kappa2 > 0) || (kappa1 > 0 && kappa2 < 0)) {
		return true;
	    }
	    return false;
	};

	public Predicate<double[]> getCondition() {
	    return condition;
	}
    }

/**
     * Offset a path in two directions.
     * Offsetting a path refers to the creation of a parallel path
     * such that the distance along the normal to one path to the
     * corresponding point on the other pass is constant.  This
     * relationship is bidirectional.  Two parallel paths will be
     * created such that one is offset from the other, and an argument
     * determines if these paths are connected to each other at their
     * ends to form a closed path.  Both will be offset from the
     * original path at most points with vertices at which the path is
     * not smooth being the main exception. These paths will be on
     * opposite sides of the original path.  The object returned will
     * be a single path. If not explicitly closed, this path will
     * contain two disjoint subpaths. If two separate paths are
     * desired, the method {@link PathSplitter#split(Path2D)} can be
     * used to provide each subpath as a separate path.
     * <P>
     * When the original path is not a closed path and a closed path is
     * requested, the path created will be a closed path oriented
     * counterclockwise: traversing one around this path will result in
     * its tangent rotating a total of 360 degrees counterclockwise.l
     * When the original path is closed, two paths will be created.
     * The outer of these two paths will have a counterclockwise orientation
     * and the inner will have a clockwise orientation.
     * <P>
     * An offset for a Bezier path cannot in general
     * be represented by a Bezier path, although it can be approximated
     * by a Bezier path. The algorithm used works best when each segment
     * of the original path has roughly constant curvature, such as when
     * a path consists of straight-line segments and segments created
     * with the createArc methods defined in this class.
     * <P>
     * The arguments dist1 and dist2 must both be non-negative.  If
     * the original path is closed, the offsetted paths will also be
     * closed. Otherwise the resulting curve will be closed if the
     * close argument has the value true.  The path will be explicitly
     * closed in this case by connecting the two paths at their
     * endpoints.  When the close argument has the value false and the
     * original path is not closed, the returned path will have two
     * separate components.  If dist1 or dist2 is zero, the corresponding
     * path will be identical to the original path.
     * @param path the original path
     * @param dist1 the distance from the path in the counterclockwise direction
     * @param dist2 the distance from the path in the clockwise direction
     * @param close true if the path returned must be a closed path;
     *        false otherwise (a value of true will result in the path
     *        specified by dist2 being reversed regardless of whether the
     *        original path is closed)
     * @return the new path.
     * @exception IllegalArgumentException dist1 or dist2 was negative
     *            or the path was null
     */
    public static Path2D offsetBy(Path2D path, double dist1, double dist2,
				  boolean close)
    {
	return offsetBy(path, dist1, dist2, close, DEFAULT_MAX_DELTA);
    }

    /**
     * Offset a path in two directions, specifying a maximum angle between
     * segments for an arc.
     * Offsetting a path refers to the creation of a parallel path
     * such that the distance along the normal to one path to the
     * corresponding point on the other pass is constant.  This
     * relationship is bidirectional.  Two parallel paths will be
     * created such that one is offset from the other, and an argument
     * determines if these paths are connected to each other at their
     * ends to form a closed path.  Both will be offset from the
     * original path at most points with vertices at which the path is
     * not smooth being the main exception. These paths will be on
     * opposite sides of the original path.  The object returned will
     * be a single path. If not explicitly closed, this path will
     * contain two disjoint subpaths. If two separate paths are
     * desired, the method {@link PathSplitter#split(Path2D)} can be
     * used to provide each subpath as a separate path.
     * <P>
     * When the original path is not a closed path and a closed path is
     * requested, the path created will be a closed path oriented
     * counterclockwise: traversing one around this path will result in
     * its tangent rotating a total of 360 degrees counterclockwise.l
     * When the original path is closed, two paths will be created.
     * The outer of these two paths will have a counterclockwise orientation
     * and the inner will have a clockwise orientation.
     * <P>
     * An offset for a Bezier path cannot in general
     * be represented by a Bezier path, although it can be approximated
     * by a Bezier path. The algorithm used works best when each segment
     * of the original path has roughly constant curvature, such as when
     * a path consists of straight-line segments and segments created
     * with the createArc methods defined in this class.
     * <P>
     * The arguments dist1 and dist2 must both be non-negative.  If
     * the original path is closed, the offsetted paths will also be
     * closed. Otherwise the resulting curve will be closed if the
     * close argument has the value true.  The path will be explicitly
     * closed in this case by connecting the two paths at their
     * endpoints.  When the close argument has the value false and the
     * original path is not closed, the returned path will have two
     * separate components.  If dist1 or dist2 is zero, the corresponding
     * path will be identical to the original path.
     * @param path the original path
     * @param dist1 the distance from the path in the counterclockwise direction
     * @param dist2 the distance from the path in the clockwise direction
     * @param close true if the path returned must be a closed path;
     *        false otherwise (a value of true will result in the path
     *        specified by dist2 being reversed regardless of whether the
     *        original path is closed)
     * @param maxDelta the maximum angle in radians for each segment of
     *        an arc, with values in the range (0.0, 2&pi;/3]
     * @return the new path.
     * @exception IllegalArgumentException dist1 or dist2 was negative
     *            or the path was null
     */
    public static Path2D offsetBy(Path2D path, double dist1, double dist2,
				  boolean close, double maxDelta)
    {
	if (path == null) {
	    throw new IllegalArgumentException(errorMsg("nullArg", 1));
	}
	if (dist1 < 0.0) {
	    throw new IllegalArgumentException(errorMsg("lessThanZero", dist1));
	}
	if (dist2 < 0.0) {
	    throw new IllegalArgumentException(errorMsg("lessThanZero", dist2));
	}
	if (maxDelta <= 0.0 || maxDelta > TWO_THIRDS_PI) {
	    throw new
		IllegalArgumentException(errorMsg("maxDelta", maxDelta));
	}

	// Helps in some cases.
	ConditionHandler ch = new ConditionHandler();
	PathIterator pit = path.getPathIterator(null);
	Path2D tpath = new Path2D.Double(pit.getWindingRule());
	pit = new ConditionalPathIterator2D(pit, ch.getCondition(), 3);
	tpath.append(pit, false);
	path = tpath;

	List<Path2DInfo.Entry> entries = Path2DInfo.getEntries(path);
	boolean sawMove = false;
	int windingRule = path.getPathIterator(null).getWindingRule();
	Path2D result1 = new Path2D.Double(windingRule);
	Path2D result2 = new Path2D.Double(windingRule);
	double[] narray0 = new double[2];
	double[] narray1 = new double[2];
	Path2DInfo.Entry prevEntry = null;
	int prevType = -1;
	double[] prevCoords = null;
	boolean hasPrevTangent0 = false;
	boolean hasPrevTangent = false;
	double[] tarray0 = new double[2];
	double[] tarray1 = new double[2];
	double[] ptarray = new double[2];
	double[] ptarray0 = new double[2];

	boolean hasPrevCurvature = false;
	boolean hasPrevCurvature0 = false;
	boolean hasPrevNormal = false;
	boolean hasPrevNormal0 = false;
	double[] pnarray = new double[2];
	double[] pnarray0 = new double[2];
	double[] xy = new double[2];
	double prevCurvature = 0.0;
	double prevCurvature0 = 0.0;
	boolean closed = false;
	Path2DInfo.SegmentData prevData = null;
	boolean breakFromLoop = false;
	for (Path2DInfo.Entry entry: entries) {
	    int type = entry.getType();
	    Path2DInfo.SegmentData data = entry.getData();
	    double[] coords = entry.getCoords();
	    double[] newCoords = null;
	    boolean hasCurvature0 = data.curvatureExists(uvZero);
	    boolean hasCurvature1 = data.curvatureExists(uvOne);
	    double curvature0 = 0.0;
	    double curvature1 = 0.0;
	    if (hasCurvature0) curvature0 = data.curvature(uvZero);
	    if (hasCurvature1) curvature1 = data.curvature(uvOne);
	    boolean hasNormal0 = data.getNormal(uvZero, narray0, 0);
	    boolean hasNormal1 = data.getNormal(uvOne, narray1, 0);
	    boolean hasTangent0 = data.getTangent(uvZero, tarray0, 0);
	    boolean hasTangent1 = data.getTangent(uvOne, tarray1, 0);

	    Point2D start, start1, start2, end1, end2;
	    switch(type) {
	    case PathIterator.SEG_MOVETO:
		if (sawMove == false && prevEntry != null) {
		    throw new
			IllegalArgumentException(errorMsg("misplacedMoveTo"));
		}
		sawMove = true;
		hasPrevCurvature = false;
		hasPrevCurvature0 = false;
		prevCurvature = 0.0;
		prevCurvature0 = 0.0;
		hasPrevNormal = false;
		hasPrevNormal0 = false;
		hasTangent0 = false;
		hasTangent1 = false;
		hasNormal1 = false;
		hasTangent1 = false;
		break;
	    case PathIterator.SEG_LINETO:
		if (sawMove) {
		    if (hasNormal0 && hasNormal1) {
			start = entry.getStart();
			result1.moveTo(start.getX()+narray0[0]*dist1,
				      start.getY()+narray0[1]*dist1);
			result2.moveTo(start.getX()-narray0[0]*dist2,
				       start.getY()-narray0[1]*dist2);
			sawMove = false;
		    }
		} else {
		    if (hasNormal0 && hasPrevNormal) {
			start = entry.getStart();
			switch(prevType) {
			case PathIterator.SEG_LINETO:
			    if (hasPrevTangent && hasTangent0) {
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    result1.lineTo(start.getX()
						   +narray0[0]*dist1,
						   start.getY()
						   +narray0[1]*dist1);
				    result2.lineTo(start.getX()
						   -narray0[0]*dist2,
						   start.getY()
						   -narray0[1]*dist2);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Path2DInfo.getLineIntersectionXY
					(start1.getX() + pnarray[0]*dist1,
					 start1.getY() + pnarray[1]*dist1,
					 end1.getX() + pnarray[0]*dist1,
					 end1.getY() + pnarray[1]*dist1,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 end2.getX() + narray0[0]*dist1,
					 end2.getY() + narray0[1]*dist1,
					 xy, 0);
				    result1.lineTo(xy[0], xy[1]);
				    double xyx =
					xy[0] -(dist1+dist2)*pnarray[0];
				    double xyy =
					xy[1] -(dist1+dist2)*pnarray[1];
				    result2.lineTo(xyx, xyy);
				    double cosAngle = ptarray[0]*tarray0[0]
					+ ptarray[1]*tarray0[1];
				    double angle =
					Math.atan2(sinAngle,cosAngle);
				    Path2D p = Paths2D.createArc
					(xy[0], xy[1], xyx, xyy, angle,
					 maxDelta);
				    result2.append(p, true);
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Path2DInfo.getLineIntersectionXY
					(start1.getX() - pnarray[0]*dist2,
					 start1.getY() - pnarray[1]*dist2,
					 end1.getX() - pnarray[0]*dist2,
					 end1.getY() - pnarray[1]*dist2,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 end2.getX() - narray0[0]*dist2,
					 end2.getY() - narray0[1]*dist2,
					 xy, 0);
				    result2.lineTo(xy[0], xy[1]);
				    double xyx =
					xy[0] + (dist1+dist2)*pnarray[0];
				    double xyy =
					xy[1] + (dist1+dist2)*pnarray[1];
				    result1.lineTo(xyx, xyy);
				    double cosAngle = ptarray[0]*tarray0[0]
					+ ptarray[1]*tarray0[1];
				    double angle =
					Math.atan2(sinAngle,cosAngle);
				    Path2D p = Paths2D.createArc
					(xy[0], xy[1], xyx, xyy, angle,
					 maxDelta);
				    result1.append(p, true);
				}
			    } else {
				// nothing to do
			    }
			    break;
			case PathIterator.SEG_CUBICTO:
			    if (hasNormal0 && hasPrevNormal) {
				double scale11 = 1.0 - prevCurvature0*dist1;
				double scale21 = 1.0 + prevCurvature0*dist2;
				double scale12 = 1.0 - prevCurvature*dist1;
				double scale22 = 1.0 + prevCurvature*dist2;
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double nvector[] = {
					start1a.getX() - start1b.getX(),
					start1a.getY() - start1b.getY()
				    };
				    double nvectorNorm = Math.sqrt
					(nvector[0]*nvector[0]
					 + nvector[1]*nvector[1]);
				    nvector[0] /= nvectorNorm;
				    nvector[1] /= nvectorNorm;
				    double tvector[] = {
					nvector[1], -nvector[0]
				    };
				    double deltax =
					prevCoords[0] - start1.getX();
				    double deltay =
					prevCoords[1] - start1.getY();
				    double delta =
					Math.sqrt(deltax*deltax
						  + deltay*deltay);
				    result1.curveTo(start1a.getX()
						    + scale11*delta*tvector[0],
						    start1a.getY()
						    + scale11*delta*tvector[1],
						    prevCoords[4]
						    + dist1*pnarray[0]
						    +scale12*(prevCoords[2]
							      - prevCoords[4]),
						    prevCoords[5]
						    + dist1*pnarray[1]
						    +scale12*(prevCoords[3]
							      - prevCoords[5]),
						    prevCoords[4]
						    + dist1*pnarray[0],
						    prevCoords[5]
						    + dist1*pnarray[1]);
				    result2.curveTo(start1b.getX()
						    + scale21*delta*tvector[0],
						    start1b.getY()
						    + scale21*delta*tvector[1],
						    prevCoords[4]
						    - dist2*pnarray[0]
						    + scale22*(prevCoords[2]
							       - prevCoords[4]),
						    prevCoords[5]
						    - dist2*pnarray[1]
						    + scale22*(prevCoords[3]
							       - prevCoords[5]),
						    prevCoords[4]
						    - dist2*pnarray[0],
						    prevCoords[5]
						    - dist2*pnarray[1]);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end1.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    double tmppcoords2[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					end2.getX() +narray1[0]*dist1,
					end2.getY() +narray1[1]*dist1,
				    };
				   double[] ourxy
				       = Path2DInfo.getSegmentIntersectionUVXY
				       (PathIterator.SEG_CUBICTO,
					 start1a.getX(), start1a.getY(),
					 tmppcoords,
					 PathIterator.SEG_LINETO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords2);
					result1.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result2.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3],
					     newcoords2[4], newcoords2[5],
					     angle, maxDelta);
					result2.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    double tmppcoords2[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end2.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					end2.getX() - narray1[0]*dist2,
					end2.getY() - narray1[1]*dist2,
				    };
				   double[] ourxy
				       = Path2DInfo.getSegmentIntersectionUVXY
				       (PathIterator.SEG_CUBICTO,
					 start1b.getX(), start1b.getY(),
					 tmppcoords,
					 PathIterator.SEG_LINETO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords2);
					result2.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result1.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3],
					     newcoords2[4], newcoords2[5],
					     angle, maxDelta);
					result1.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			}
		    }
		}
		break;
	    case PathIterator.SEG_QUADTO:
		newCoords = new double[6];
		start = entry.getStart();
		Path2DInfo.elevateDegree(2, newCoords,
					 start.getX(), start.getY(),
					 coords);
		coords = newCoords;
		type = PathIterator.SEG_CUBICTO;
		// fall through
	    case PathIterator.SEG_CUBICTO:
		if (sawMove) {
		    if (hasNormal0 && hasNormal1) {
			start = entry.getStart();
			result1.moveTo(start.getX()+narray0[0]*dist1,
				      start.getY()+narray0[1]*dist1);
			result2.moveTo(start.getX()-narray0[0]*dist2,
				      start.getY()-narray0[1]*dist2);
			sawMove = false;
		    }
		} else {
		    if (hasNormal0 && hasPrevNormal) {
			start = entry.getStart();
			switch(prevType) {
			case PathIterator.SEG_LINETO:
			    if (hasPrevTangent && hasTangent0) {
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    result1.lineTo(start.getX()
						   +narray0[0]*dist1,
						   start.getY()
						   +narray0[1]*dist1);
				    result2.lineTo(start.getX()
						   -narray0[0]*dist2,
						   start.getY()
						   -narray0[1]*dist2);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmppcoords[] = {
					 end1.getX() + pnarray[0]*dist1,
					 end1.getY() + pnarray[1]*dist1
				    };
				    double scale1 =
					1.0 - (curvature0)*dist1;
				    double scale2 =
					1.0 - (curvature1)*dist1;
				    double tmpcoords[] = {
					start2.getX() + narray0[0]*dist1
					+ scale1*(coords[0] - start2.getX()),
					start2.getY() + narray0[1]*dist1
					+ scale1*(coords[1] - start2.getY()),
					end2.getX() + narray1[0]*dist1
					+ scale2 * (coords[2] - end2.getX()),
					end2.getY() + narray1[1]*dist1
					+ scale2 * (coords[3] - end2.getY()),
					end2.getX() + narray1[0]*dist1,
					end2.getY() + narray1[1]*dist1
				    };
				    double[] ourxy =
					Path2DInfo.getSegmentIntersectionXY
					(PathIterator.SEG_LINETO,
					 start1.getX() + pnarray[0]*dist1,
					 start1.getY() + pnarray[1]*dist1,
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					result1.lineTo(ourxy[0], ourxy[1]);
					double xyx =
					    ourxy[0] - (dist1+dist2)*pnarray[0];
					double xyy =
					    ourxy[1] - (dist1+dist2)*pnarray[1];
					result2.lineTo(xyx, xyy);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[0], ourxy[1],
					     xyx, xyy, angle, maxDelta);
					result2.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmppcoords[] = {
					 end1.getX() - pnarray[0]*dist2,
					 end1.getY() - pnarray[1]*dist2
				    };
				    double scale1 = 1.0 + curvature0*dist2;
				    double scale2 = 1.0 + curvature1*dist2;
				    double tmpcoords[] = {
					start2.getX() - narray0[0]*dist2
					+ scale1*(coords[0] - start2.getX()),
					start2.getY() - narray0[1]*dist2
					+ scale1*(coords[1] - start2.getY()),
					end2.getX() - narray1[0]*dist2
					+ scale1 * (coords[2] - end2.getX()),
					end2.getY() - narray1[1]*dist2
					+ scale2 * (coords[3] - end2.getY()),
					end2.getX() - narray1[0]*dist2,
					end2.getY() - narray1[1]*dist2
				    };
				    double[] ourxy =
					Path2DInfo.getSegmentIntersectionXY
					(PathIterator.SEG_LINETO,
					 start1.getX() - pnarray[0]*dist2,
					 start1.getY() - pnarray[1]*dist2,
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if(ourxy != null) {
					result2.lineTo(ourxy[0], ourxy[1]);
					double xyx =
					    ourxy[0] + (dist1+dist2)*pnarray[0];
					double xyy =
					    ourxy[1] + (dist1+dist2)*pnarray[1];
					result1.lineTo(xyx, xyy);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[0], ourxy[1],
					     xyx, xyy, angle, maxDelta);
					result1.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			case PathIterator.SEG_CUBICTO:
			    if (hasNormal0 && hasPrevNormal) {
				double scale11 = 1.0 - prevCurvature0*dist1;
				double scale21 = 1.0 + prevCurvature0*dist2;
				double scale12 = 1.0 - prevCurvature*dist1;
				double scale22 = 1.0 + prevCurvature*dist2;
				double nscale11 = 1.0 - curvature0*dist1;
				double nscale21 = 1.0 + curvature0*dist2;
				double nscale12 = 1.0 - curvature1*dist1;
				double nscale22 = 1.0 + curvature1*dist2;
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double nvector[] = {
					start1a.getX() - start1b.getX(),
					start1a.getY() - start1b.getY()
				    };
				    double nvectorNorm = Math.sqrt
					(nvector[0]*nvector[0]
					 + nvector[1]*nvector[1]);
				    nvector[0] /= nvectorNorm;
				    nvector[1] /= nvectorNorm;
				    double tvector[] = {
					nvector[1], -nvector[0]
				    };
				    double deltax =
					prevCoords[0] - start1.getX();
				    double deltay =
					prevCoords[1] - start1.getY();
				    double delta =
					Math.sqrt(deltax*deltax
						  + deltay*deltay);
				    result1.curveTo(start1a.getX()
						    + scale11*delta*tvector[0],
						    start1a.getY()
						    + scale11*delta*tvector[1],
						    prevCoords[4]
						    + dist1*pnarray[0]
						    +scale12*(prevCoords[2]
							      - prevCoords[4]),
						    prevCoords[5]
						    + dist1*pnarray[1]
						    +scale12*(prevCoords[3]
							      - prevCoords[5]),
						    prevCoords[4]
						    + dist1*pnarray[0],
						    prevCoords[5]
						    + dist1*pnarray[1]);
				    result2.curveTo(start1b.getX()
						    + scale21*delta*tvector[0],
						    start1b.getY()
						    + scale21*delta*tvector[1],
						    prevCoords[4]
						    - dist2*pnarray[0]
						    + scale22*(prevCoords[2]
							       - prevCoords[4]),
						    prevCoords[5]
						    - dist2*pnarray[1]
						    + scale22*(prevCoords[3]
							       - prevCoords[5]),
						    prevCoords[4]
						    - dist2*pnarray[0],
						    prevCoords[5]
						    - dist2*pnarray[1]);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end1.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    double tmppcoords2[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					start2.getX() + narray0[0]*dist1
					+ nscale21*(coords[0]-start1.getX()),
					start2.getY() + narray0[1]*dist1
					+ nscale21*(coords[1]-start1.getY()),
					end2.getX() + narray1[0]*dist1
					+ nscale22*(coords[2]-end2.getX()),
					end2.getY() + narray1[1]*dist1
					+ nscale22*(coords[3]-end2.getY()),
					end2.getX() + narray1[0]*dist1,
					end2.getY() + narray1[1]*dist1
				    };
				   double[] ourxy
				       = Path2DInfo.getSegmentIntersectionUVXY
				       (PathIterator.SEG_CUBICTO,
					 start1a.getX(), start1a.getY(),
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords2);
					result1.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result2.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3],
					     newcoords2[4],
					     newcoords2[5],
					     angle, maxDelta);
					result2.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    double tmppcoords2[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end2.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					start2.getX() - narray0[0]*dist2
					+ nscale21*(coords[0]-start1.getX()),
					start2.getY() - narray0[1]*dist2
					+ nscale21*(coords[1]-start1.getY()),
					end2.getX() - narray1[0]*dist2
					+ nscale22*(coords[2]-end2.getX()),
					end2.getY() - narray1[1]*dist2
					+ nscale22*(coords[3]-end2.getY()),
					end2.getX() - narray1[0]*dist2,
					end2.getY() + narray1[1]*dist2
				    };
				   double[] ourxy
				       = Path2DInfo.getSegmentIntersectionUVXY
				       (PathIterator.SEG_CUBICTO,
					 start1b.getX(), start1b.getY(),
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords2);
					result2.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result1.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3],
					     newcoords2[4],
					     newcoords2[5],
					     angle, maxDelta);
					result1.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			}
		    }
		}
		break;
	    case PathIterator.SEG_CLOSE:
		closed = true;
		sawMove = false;
		breakFromLoop = true;
		break;
	    }
	    if (breakFromLoop) break;
	    prevEntry = entry;
	    prevData = data;
	    prevType = type;
	    prevCoords = coords;
	    hasPrevNormal = hasNormal1;
	    if (hasPrevNormal) {
		System.arraycopy(narray1, 0, pnarray, 0, 2);
	    }
	    hasPrevTangent0 =  hasTangent0;
	    if (hasPrevTangent0) {
		System.arraycopy(tarray0, 0, ptarray0, 0, 2);
	    }
	    hasPrevTangent = hasTangent1;
	    if (hasPrevTangent) {
		System.arraycopy(tarray1, 0, ptarray, 0, 2);
	    }
	    hasPrevCurvature0 = hasCurvature0;
	    if (hasPrevCurvature0) {
		prevCurvature0 = curvature0;
	    }
	    hasPrevCurvature = hasCurvature1;
	    if (hasPrevCurvature) {
		prevCurvature = curvature1;
	    }
	}
	Point2D end = prevEntry.getEnd();

	switch(prevEntry.getType()) {
	case PathIterator.SEG_LINETO:
	    if (hasPrevNormal) {
		result1.lineTo(end.getX() + pnarray[0]*dist1,
			       end.getY() + pnarray[1]*dist1);
		result2.lineTo(end.getX() - pnarray[0]*dist2,
			       end.getY() - pnarray[1]*dist2);
	    }
	    break;
	case PathIterator.SEG_CUBICTO:
	    if (hasPrevNormal) {
		double scale11 = 1.0 - prevCurvature0*dist1;
		double scale21 = 1.0 + prevCurvature0*dist2;
		double scale12 = 1.0 - prevCurvature*dist1;
		double scale22 = 1.0 + prevCurvature*dist2;
		Point2D start1 = prevEntry.getStart();
		Point2D end1 = prevEntry.getEnd();
		Point2D start1a = result1.getCurrentPoint();
		Point2D start1b = result2.getCurrentPoint();
		double nvector[] = {
		    start1a.getX() - start1b.getX(),
		    start1a.getY() - start1b.getY()
		};
		double nvectorNorm = Math.sqrt(nvector[0]*nvector[0]
					       + nvector[1]*nvector[1]);
		nvector[0] /= nvectorNorm;
		nvector[1] /= nvectorNorm;
		double tvector[] = {nvector[1], -nvector[0]};
		double deltax = prevCoords[0] - start1.getX();
		double deltay = prevCoords[1] - start1.getY();
		double delta = Math.sqrt(deltax*deltax + deltay*deltay);
		result1.curveTo(start1a.getX() + scale11*delta*tvector[0],
				start1a.getY() + scale11*delta*tvector[1],
				prevCoords[4] + dist1*pnarray[0]
				+scale12*(prevCoords[2] - prevCoords[4]),
				prevCoords[5] + dist1*pnarray[1]
				+scale12*(prevCoords[3] - prevCoords[5]),
				prevCoords[4] + dist1*pnarray[0],
				prevCoords[5] + dist1*pnarray[1]);
		result2.curveTo(start1b.getX() + scale21*delta*tvector[0],
				start1b.getY() + scale21*delta*tvector[1],
				prevCoords[4] - dist2*pnarray[0]
				+ scale22*(prevCoords[2] - prevCoords[4]),
				prevCoords[5] - dist2*pnarray[1]
				+ scale22*(prevCoords[3] - prevCoords[5]),
				prevCoords[4] - dist2*pnarray[0],
				prevCoords[5] - dist2*pnarray[1]);

	    }
	}
	/*
	if (close) result2 = reverse(result2);
	if (closed) {
	    result1.append(result2, false);
	} else if (close) {
	    result1.append(result2, true);
	    result1.closePath();
	} else {
	    result1.append(result2, false);
	}
	return result1;
	*/
	if (close || closed) result1 = reverse(result1);
	if (closed) {
	    if (close) {
		result1.closePath();
		result2.closePath();
	    }
	    result2.append(result1, false);
	} else if (close) {
	    result2.append(result1, true);
	    result2.closePath();
	} else {
	    result2.append(result1, false);
	}
	return result2;
    }

     private static Point2D interpolate(Point2D p1, Point2D p2, double f,
					boolean pccw)
     {
	 // p1 corresponds to dist1 and p2 corresponds to dist2.
	 double omf = 1.0 - f;
	 if (pccw) {
	     return new Point2D.Double(p1.getX()*omf + f*p2.getX(),
				       p1.getY()*omf + f*p2.getY());
	 } else {
	     return new Point2D.Double(p2.getX()*omf + f*p1.getX(),
				       p2.getY()*omf + f*p1.getY());
	 }
     }

     private static void interpolate(double[] coords1, double[] coords2,
				     double[] coords3,
				     double f, boolean pccw)
     {
	 // p1 corresponds to dist1 and p2 corresponds to dist2.
	 // always degree 3.
	 double omf = 1.0 - f;
	 if (pccw) {
	     for (int i = 0; i < 6; i++) {
		 coords3[i] = coords1[i]*omf + f*coords2[i];
	     }
	 } else {
	     for (int i = 0; i < 6; i++) {
		 coords3[i] = coords2[i]*omf + f*coords1[i];
	     }
	 }
     }

     private static double interpFactor(double dist1, double dist2,
					double dist3,
					boolean pccw, boolean ccw)
     {
	 double dist;
	 if (pccw) {
	     dist = (ccw)? (dist1 - dist3): (dist1  + dist3);
	 } else {
	     dist = (ccw)? (dist2 + dist3): (dist2 - dist3);
	 }
	 return dist/(dist1+dist2);
     }

    /**
     * Offset a path by interpolating the paths provided by
     * {@link #offsetBy(Path2D,double,double,boolean)}  or
     * {@link #offsetBy(Path2D,double,double,boolean,double)}.
     * Offsetting a path refers to the creation of a parallel path such
     * that the distance along the normal to one path to the corresponding
     * point on the other pass is constant. An offset for a Bezier path
     * cannot in general be represented by a Bezier path, although it
     * can be approximated by a Bezier path. The method
     * {@link #offsetBy(Path2D,double,double,boolean)} creates an approximation
     * to two offset Bezier paths, each one on the opposite side of the
     * original (or base) path than the other. This method uses these two
     * paths and interpolates them to create a single path between the two.
     * <P>
     * The arguments dist1 and dist2 must both be non-negative.  If
     * the original path is closed the offsetted paths will also be
     * closed. Otherwise the resulting curve will be closed if the
     * close argument has the value true.  The path will be explicitly
     * closed in this case by connecting the two paths at their
     * endpoints.  When the close argument has the value false and the
     * original path is not closed, the returned path will have two
     * separate components.
     * <P>
     * The argument dist3 provides the nominal distance from the
     * original or base path to the curve.  The curve created will be
     * a smooth curve regardless of whether or not the base curve is
     * smooth, Kinks in the base curve will be smoothed out with
     * circular arcs.  The center of these circular arcs will be a
     * point on the curves associated with the parameters dist1 and
     * dist2, only one of which will not be smooth at some value of
     * the path parameter.
     * @param path the path to offset.
     * @param dist1 the distance from the path in the counterclockwise direction
     * @param dist2 the distance from the path in the clockwise direction
     * @param dist3 the distance from the path (when ccw is true,
     *        dist3&isin;[0, dist1]; otherwise dist2&isin;[0,dist2])
     * @param ccw true if dist3 is measured in the counterclockwise direction;
     *        false if it is measured in the clockwise direction.
     * @return the new path.
     * @exception IllegalArgumentException dist1 or dist2 was negative
     *            or the path was null
     */
    public static Path2D offsetBy(Path2D path, double dist1, double dist2,
				  double dist3, boolean ccw)
    {
	return offsetBy(path, dist1, dist2, dist3, ccw, DEFAULT_MAX_DELTA);
    }

    /**
     * Offset a path by interpolating the paths provided by
     * {@link #offsetBy(Path2D,double,double,boolean)} or
     * {@link #offsetBy(Path2D,double,double,boolean,double)},
     * specifying a maximum angle between segments for an arc.
     * Offsetting a path refers to the creation of a parallel path such
     * that the distance along the normal to one path to the corresponding
     * point on the other pass is constant. An offset for a Bezier path
     * cannot in general be represented by a Bezier path, although it
     * can be approximated by a Bezier path. The method
     * {@link #offsetBy(Path2D,double,double,boolean)} creates an approximation
     * to two offset Bezier paths, each one on the opposite side of the
     * original (or base) path than the other. This method uses these two
     * paths and interpolates them to create a single path between the two.
     * <P>
     * The arguments dist1 and dist2 must both be non-negative.  If
     * the original path is closed the offsetted paths will also be
     * closed. Otherwise the resulting curve will be closed if the
     * close argument has the value true.  The path will be explicitly
     * closed in this case by connecting the two paths at their
     * endpoints.  When the close argument has the value false and the
     * original path is not closed, the returned path will have two
     * separate components.
     * <P>
     * The argument dist3 provides the nominal distance from the
     * original or base path to the curve.  The curve created will be
     * a smooth curve regardless of whether or not the base curve is
     * smooth, Kinks in the base curve will be smoothed out with
     * circular arcs.  The center of these circular arcs will be a
     * point on the curves associated with the parameters dist1 and
     * dist2, only one of which will not be smooth at some value of
     * the path parameter.
     * @param path the path to offset.
     * @param dist1 the distance from the path in the counterclockwise direction
     * @param dist2 the distance from the path in the clockwise direction
     * @param dist3 the distance from the path (when ccw is true,
     *        dist3&isin;[0, dist1]; otherwise dist2&isin;[0,dist2])
     * @param ccw true if dist3 is measured in the counterclockwise direction;
     *        false if it is measured in the clockwise direction.
     * @param maxDelta the maximum angle in radians for each segment of
     *        an arc, with values in the range (0.0, 2&pi;/3]
     * @return the new path.
     * @exception IllegalArgumentException dist1 or dist2 was negative
     *            or the path was null
     */
    public static Path2D offsetBy(Path2D path, double dist1, double dist2,
				  double dist3, boolean ccw, double maxDelta)
    {
	if (path == null) {
	    throw new IllegalArgumentException(errorMsg("nullArg", 1));
	}
	if (dist1 < 0) {
	    throw new IllegalArgumentException(errorMsg("lessThanZero", dist1));
	}
	if (dist2 < 0) {
	    throw new IllegalArgumentException(errorMsg("lessThanZero", dist2));
	}

	if (dist3 < 0) {
	    throw new IllegalArgumentException(errorMsg("lessThanZero", dist2));
	}

	if (maxDelta <= 0.0 || maxDelta > TWO_THIRDS_PI) {
	    throw new
		IllegalArgumentException(errorMsg("maxDelta", maxDelta));
	}

	// Helps in some cases.
	ConditionHandler ch = new ConditionHandler();
	PathIterator pit = path.getPathIterator(null);
	Path2D tpath = new Path2D.Double(pit.getWindingRule());
	pit = new ConditionalPathIterator2D(pit, ch.getCondition(), 3);
	tpath.append(pit, false);
	path = tpath;

	List<Path2DInfo.Entry> entries = Path2DInfo.getEntries(path);
	boolean sawMove = false;
	int windingRule = path.getPathIterator(null).getWindingRule();
	Path2D result1 = new Path2D.Double(windingRule);
	Path2D result2 = new Path2D.Double(windingRule);
	Path2D result3 = new Path2D.Double(windingRule);
	double[] narray0 = new double[2];
	double[] narray1 = new double[2];
	Path2DInfo.Entry prevEntry = null;
	int prevType = -1;
	double[] prevCoords = null;
	boolean hasPrevTangent0 = false;
	boolean hasPrevTangent = false;
	double[] tarray0 = new double[2];
	double[] tarray1 = new double[2];
	double[] ptarray = new double[2];
	double[] ptarray0 = new double[2];

	boolean hasPrevCurvature = false;
	boolean hasPrevCurvature0 = false;
	boolean hasPrevNormal = false;
	boolean hasPrevNormal0 = false;
	double[] pnarray = new double[2];
	double[] pnarray0 = new double[2];
	double[] xy = new double[2];
	double prevCurvature = 0.0;
	double prevCurvature0 = 0.0;
	boolean closed = false;
	Path2DInfo.SegmentData prevData = null;
	boolean breakFromLoop = false;

	double[] pcoords3 = new double[6];

	for (Path2DInfo.Entry entry: entries) {
	    int type = entry.getType();
	    Path2DInfo.SegmentData data = entry.getData();
	    double[] coords = entry.getCoords();
	    double[] newCoords = null;
	    boolean hasCurvature0 = data.curvatureExists(uvZero);
	    boolean hasCurvature1 = data.curvatureExists(uvOne);
	    double curvature0 = 0.0;
	    double curvature1 = 0.0;
	    if (hasCurvature0) curvature0 = data.curvature(uvZero);
	    if (hasCurvature1) curvature1 = data.curvature(uvOne);
	    boolean hasNormal0 = data.getNormal(uvZero, narray0, 0);
	    boolean hasNormal1 = data.getNormal(uvOne, narray1, 0);
	    boolean hasTangent0 = data.getTangent(uvZero, tarray0, 0);
	    boolean hasTangent1 = data.getTangent(uvOne, tarray1, 0);

	    Point2D start, start1, start2, end1, end2;
	    switch(type) {
	    case PathIterator.SEG_MOVETO:
		if (sawMove == false && prevEntry != null) {
		    throw new
			IllegalArgumentException(errorMsg("misplacedMoveTo"));
		}
		sawMove = true;
		hasPrevCurvature = false;
		hasPrevCurvature0 = false;
		prevCurvature = 0.0;
		prevCurvature0 = 0.0;
		hasPrevNormal = false;
		hasPrevNormal0 = false;
		hasTangent0 = false;
		hasTangent1 = false;
		hasNormal1 = false;
		hasTangent1 = false;
		break;
	    case PathIterator.SEG_LINETO:
		if (sawMove) {
		    if (hasNormal0 && hasNormal1) {
			start = entry.getStart();
			result1.moveTo(start.getX()+narray0[0]*dist1,
				       start.getY()+narray0[1]*dist1);
			result2.moveTo(start.getX()-narray0[0]*dist2,
				       start.getY()-narray0[1]*dist2);
			double f = interpFactor(dist1, dist2, dist3, true, ccw);
			Point2D p3 = interpolate(result1.getCurrentPoint(),
						 result2.getCurrentPoint(),
						 f, true);
			result3.moveTo(p3.getX(), p3.getY());
			sawMove = false;
		    }
		} else {
		    if (hasNormal0 && hasPrevNormal) {
			start = entry.getStart();
			switch(prevType) {
			case PathIterator.SEG_LINETO:
			    if (hasPrevTangent && hasTangent0) {
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    result1.lineTo(start.getX()
						   +narray0[0]*dist1,
						   start.getY()
						   +narray0[1]*dist1);
				    result2.lineTo(start.getX()
						   -narray0[0]*dist2,
						   start.getY()
						   -narray0[1]*dist2);
				    double f = interpFactor(dist1, dist2,
							    dist3, true, ccw);
				    Point2D p3 =
					interpolate(result1.getCurrentPoint(),
						    result2.getCurrentPoint(),
						    f, true);
				    result3.lineTo(p3.getX(), p3.getY());
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Path2DInfo.getLineIntersectionXY
					(start1.getX() + pnarray[0]*dist1,
					 start1.getY() + pnarray[1]*dist1,
					 end1.getX() + pnarray[0]*dist1,
					 end1.getY() + pnarray[1]*dist1,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 end2.getX() + narray0[0]*dist1,
					 end2.getY() + narray0[1]*dist1,
					 xy, 0);
				    result1.lineTo(xy[0], xy[1]);
				    double xyx =
					xy[0] -(dist1+dist2)*pnarray[0];
				    double xyy =
					xy[1] -(dist1+dist2)*pnarray[1];
				    result2.lineTo(xyx, xyy);
				    double cosAngle = ptarray[0]*tarray0[0]
					+ ptarray[1]*tarray0[1];
				    double angle =
					Math.atan2(sinAngle,cosAngle);
				    Path2D p = Paths2D.createArc
					(xy[0], xy[1], xyx, xyy, angle,
					 maxDelta);
				    double f = interpFactor(dist1, dist2,
							    dist3, true, ccw);
				    Point2D p3 =
					interpolate(result1.getCurrentPoint(),
						    result2.getCurrentPoint(),
						    f, true);
				    result3.lineTo(p3.getX(), p3.getY());
				    result2.append(p, true);
				    p3 = result3.getCurrentPoint();
				    p = Paths2D.createArc(xy[0], xy[1],
							  p3.getX(), p3.getY(),
							  angle, maxDelta);
				    result3.append(p, true);
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Path2DInfo.getLineIntersectionXY
					(start1.getX() - pnarray[0]*dist2,
					 start1.getY() - pnarray[1]*dist2,
					 end1.getX() - pnarray[0]*dist2,
					 end1.getY() - pnarray[1]*dist2,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 end2.getX() - narray0[0]*dist2,
					 end2.getY() - narray0[1]*dist2,
					 xy, 0);
				    result2.lineTo(xy[0], xy[1]);
				    double xyx =
					xy[0] + (dist1+dist2)*pnarray[0];
				    double xyy =
					xy[1] + (dist1+dist2)*pnarray[1];
				    result1.lineTo(xyx, xyy);
				    double cosAngle = ptarray[0]*tarray0[0]
					+ ptarray[1]*tarray0[1];
				    double angle =
					Math.atan2(sinAngle,cosAngle);
				    Path2D p = Paths2D.createArc
					(xy[0], xy[1], xyx, xyy, angle,
					 maxDelta);
				    double f = interpFactor(dist1, dist2,
							    dist3, false, ccw);
				    Point2D p3 =
					interpolate(result1.getCurrentPoint(),
						    result2.getCurrentPoint(),
						    f, false);
				    result3.lineTo(p3.getX(), p3.getY());
				    result1.append(p, true);
				    p3 = result3.getCurrentPoint();
				    p = Paths2D.createArc(xy[0], xy[1],
							  p3.getX(), p3.getY(),
							  angle, maxDelta);
				    result3.append(p, true);
				}
			    } else {
				// nothing to do
			    }
			    break;
			case PathIterator.SEG_CUBICTO:
			    if (hasNormal0 && hasPrevNormal) {
				double scale11 = 1.0 - prevCurvature0*dist1;
				double scale21 = 1.0 + prevCurvature0*dist2;
				double scale12 = 1.0 - prevCurvature*dist1;
				double scale22 = 1.0 + prevCurvature*dist2;
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double nvector[] = {
					start1a.getX() - start1b.getX(),
					start1a.getY() - start1b.getY()
				    };
				    double nvectorNorm = Math.sqrt
					(nvector[0]*nvector[0]
					 + nvector[1]*nvector[1]);
				    nvector[0] /= nvectorNorm;
				    nvector[1] /= nvectorNorm;
				    double tvector[] = {
					nvector[1], -nvector[0]
				    };
				    double deltax =
					prevCoords[0] - start1.getX();
				    double deltay =
					prevCoords[1] - start1.getY();
				    double delta =
					Math.sqrt(deltax*deltax
						  + deltay*deltay);
				    double[] pcoords1 = {
					start1a.getX()+scale11*delta*tvector[0],
					start1a.getY()+scale11*delta*tvector[1],
					prevCoords[4] + dist1*pnarray[0]
					+scale12*(prevCoords[2]-prevCoords[4]),
					prevCoords[5] + dist1*pnarray[1]
					+scale12*(prevCoords[3]-prevCoords[5]),
					prevCoords[4] + dist1*pnarray[0],
					prevCoords[5] + dist1*pnarray[1]
				    };

				    result1.curveTo(pcoords1[0], pcoords1[1],
						    pcoords1[2], pcoords1[3],
						    pcoords1[4], pcoords1[5]);
				    double[] pcoords2 = {
					start1b.getX()+scale21*delta*tvector[0],
					start1b.getY()+scale21*delta*tvector[1],
					prevCoords[4]-dist2*pnarray[0]
					+ scale22*(prevCoords[2]-prevCoords[4]),
					prevCoords[5] - dist2*pnarray[1]
					+ scale22*(prevCoords[3]-prevCoords[5]),
					prevCoords[4] - dist2*pnarray[0],
					prevCoords[5] - dist2*pnarray[1]
				    };
				    result2.curveTo(pcoords2[0], pcoords2[1],
						    pcoords2[2], pcoords2[3],
						    pcoords2[4], pcoords2[5]);
				    double f = interpFactor(dist1, dist2,
							    dist3, true, ccw);
				    interpolate(pcoords1, pcoords2, pcoords3,
						f, true);
				    result3.curveTo(pcoords3[0], pcoords3[1],
						    pcoords3[2], pcoords3[3],
						    pcoords3[4], pcoords3[5]);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end1.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    double tmppcoords2[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					end2.getX() +narray1[0]*dist1,
					end2.getY() +narray1[1]*dist1,
				    };
				    double[] ourxy
					= Path2DInfo.getSegmentIntersectionUVXY
					(PathIterator.SEG_CUBICTO,
					 start1a.getX(), start1a.getY(),
					 tmppcoords,
					 PathIterator.SEG_LINETO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords2);
					result1.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result2.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double f = interpFactor(dist1, dist2,
								dist3, true,
								ccw);
					interpolate(newcoords1, newcoords2,
						    pcoords3, f, true);
					result3.curveTo(pcoords3[0],
							pcoords3[1],
							pcoords3[2],
							pcoords3[3],
							pcoords3[4],
							pcoords3[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3], newcoords2[4],
					     newcoords2[5], angle, maxDelta);
					result2.append(p, true);
					Point2D p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[2],
							      ourxy[3],
							      p3.getX(),
							      p3.getY(),
							      angle, maxDelta);
					result3.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    double tmppcoords2[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end2.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					end2.getX() - narray1[0]*dist2,
					end2.getY() - narray1[1]*dist2,
				    };
				    double[] ourxy
					= Path2DInfo.getSegmentIntersectionUVXY
					(PathIterator.SEG_CUBICTO,
					 start1b.getX(), start1b.getY(),
					 tmppcoords,
					 PathIterator.SEG_LINETO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords2);
					result2.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result1.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double f = interpFactor(dist1, dist2,
								dist3, false,
								ccw);
					interpolate(newcoords2, newcoords1,
						    pcoords3, f, false);
					result3.curveTo(pcoords3[0],
							pcoords3[1],
							pcoords3[2],
							pcoords3[3],
							pcoords3[4],
							pcoords3[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3], newcoords2[4],
					     newcoords2[5], angle, maxDelta);
					result1.append(p, true);
					Point2D p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[2],
							      ourxy[3],
							      p3.getX(),
							      p3.getY(),
							      angle, maxDelta);
					result3.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			}
		    }
		}
		break;
	    case PathIterator.SEG_QUADTO:
		newCoords = new double[6];
		start = entry.getStart();
		Path2DInfo.elevateDegree(2, newCoords,
					 start.getX(), start.getY(),
					 coords);
		coords = newCoords;
		type = PathIterator.SEG_CUBICTO;
		// fall through
	    case PathIterator.SEG_CUBICTO:
		if (sawMove) {
		    if (hasNormal0 && hasNormal1) {
			start = entry.getStart();
			result1.moveTo(start.getX()+narray0[0]*dist1,
				       start.getY()+narray0[1]*dist1);
			result2.moveTo(start.getX()-narray0[0]*dist2,
				       start.getY()-narray0[1]*dist2);
			double f = interpFactor(dist1, dist2, dist3, true, ccw);
			Point2D p3 = interpolate(result1.getCurrentPoint(),
						 result2.getCurrentPoint(),
						 f, true);
			result3.moveTo(p3.getX(), p3.getY());
			sawMove = false;
		    }
		} else {
		    if (hasNormal0 && hasPrevNormal) {
			start = entry.getStart();
			switch(prevType) {
			case PathIterator.SEG_LINETO:
			    if (hasPrevTangent && hasTangent0) {
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    result1.lineTo(start.getX()
						   +narray0[0]*dist1,
						   start.getY()
						   +narray0[1]*dist1);
				    result2.lineTo(start.getX()
						   -narray0[0]*dist2,
						   start.getY()
						   -narray0[1]*dist2);
				    double f = interpFactor(dist1, dist2,
							    dist3, true, ccw);
				    Point2D p3 =
					interpolate(result1.getCurrentPoint(),
						    result2.getCurrentPoint(),
						    f, true);
				    result3.lineTo(p3.getX(), p3.getY());
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmppcoords[] = {
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    double scale1 =
					1.0 - (curvature0)*dist1;
				    double scale2 =
					1.0 - (curvature1)*dist1;
				    double tmpcoords[] = {
					start2.getX() + narray0[0]*dist1
					+ scale1*(coords[0] - start2.getX()),
					start2.getY() + narray0[1]*dist1
					+ scale1*(coords[1] - start2.getY()),
					end2.getX() + narray1[0]*dist1
					+ scale2 * (coords[2] - end2.getX()),
					end2.getY() + narray1[1]*dist1
					+ scale2 * (coords[3] - end2.getY()),
					end2.getX() + narray1[0]*dist1,
					end2.getY() + narray1[1]*dist1
				    };
				    double[] ourxy =
					Path2DInfo.getSegmentIntersectionXY
					(PathIterator.SEG_LINETO,
					 start1.getX() + pnarray[0]*dist1,
					 start1.getY() + pnarray[1]*dist1,
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					result1.lineTo(ourxy[0], ourxy[1]);
					double xyx =
					    ourxy[0] - (dist1+dist2)*pnarray[0];
					double xyy =
					    ourxy[1] - (dist1+dist2)*pnarray[1];
					result2.lineTo(xyx, xyy);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc(ourxy[0],
								     ourxy[1],
								     xyx, xyy,
								     angle,
								     maxDelta);
					double f =
					    interpFactor(dist1, dist2, dist3,
							 true, ccw);
					Point2D p3 = interpolate
					    (result1.getCurrentPoint(),
					     result2.getCurrentPoint(),
					     f, true);
					result3.lineTo(p3.getX(), p3.getY());
					result2.append(p, true);
					p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[0],
							      ourxy[1],
							      p3.getX(),
							      p3.getY(),
							      angle,
							      maxDelta);
					result3.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmppcoords[] = {
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    double scale1 = 1.0 + curvature0*dist2;
				    double scale2 = 1.0 + curvature1*dist2;
				    double tmpcoords[] = {
					start2.getX() - narray0[0]*dist2
					+ scale1*(coords[0] - start2.getX()),
					start2.getY() - narray0[1]*dist2
					+ scale1*(coords[1] - start2.getY()),
					end2.getX() - narray1[0]*dist2
					+ scale1 * (coords[2] - end2.getX()),
					end2.getY() - narray1[1]*dist2
					+ scale2 * (coords[3] - end2.getY()),
					end2.getX() - narray1[0]*dist2,
					end2.getY() - narray1[1]*dist2
				    };
				    double[] ourxy =
					Path2DInfo.getSegmentIntersectionXY
					(PathIterator.SEG_LINETO,
					 start1.getX() - pnarray[0]*dist2,
					 start1.getY() - pnarray[1]*dist2,
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if(ourxy != null) {
					result2.lineTo(ourxy[0], ourxy[1]);
					double xyx =
					    ourxy[0] + (dist1+dist2)*pnarray[0];
					double xyy =
					    ourxy[1] + (dist1+dist2)*pnarray[1];
					result1.lineTo(xyx, xyy);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc(ourxy[0],
								     ourxy[1],
								     xyx, xyy,
								     angle,
								     maxDelta);
					double f =
					    interpFactor(dist1, dist2, dist3,
							 false, ccw);
					Point2D p3 = interpolate
					    (result1.getCurrentPoint(),
					     result2.getCurrentPoint(),
					     f, false);
					result3.lineTo(p3.getX(), p3.getY());
					result1.append(p, true);
					p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[0],
							      ourxy[1],
							      p3.getX(),
							      p3.getY(),
							      angle,
							      maxDelta);
					result3.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			case PathIterator.SEG_CUBICTO:
			    if (hasNormal0 && hasPrevNormal) {
				double scale11 = 1.0 - prevCurvature0*dist1;
				double scale21 = 1.0 + prevCurvature0*dist2;
				double scale12 = 1.0 - prevCurvature*dist1;
				double scale22 = 1.0 + prevCurvature*dist2;
				double nscale11 = 1.0 - curvature0*dist1;
				double nscale21 = 1.0 + curvature0*dist2;
				double nscale12 = 1.0 - curvature1*dist1;
				double nscale22 = 1.0 + curvature1*dist2;
				double sinAngle = ptarray[0]*tarray0[1]
				    - tarray0[0]*ptarray[1];
				if (Math.abs(sinAngle) < ANGLE_LIMIT) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double nvector[] = {
					start1a.getX() - start1b.getX(),
					start1a.getY() - start1b.getY()
				    };
				    double nvectorNorm = Math.sqrt
					(nvector[0]*nvector[0]
					 + nvector[1]*nvector[1]);
				    nvector[0] /= nvectorNorm;
				    nvector[1] /= nvectorNorm;
				    double tvector[] = {
					nvector[1], -nvector[0]
				    };
				    double deltax =
					prevCoords[0] - start1.getX();
				    double deltay =
					prevCoords[1] - start1.getY();
				    double delta =
					Math.sqrt(deltax*deltax
						  + deltay*deltay);
				    double pcoords1[] = {
					start1a.getX()+scale11*delta*tvector[0],
					start1a.getY()+scale11*delta*tvector[1],
					prevCoords[4] + dist1*pnarray[0]
					+ scale12*(prevCoords[2]-prevCoords[4]),
					prevCoords[5] + dist1*pnarray[1]
					+ scale12*(prevCoords[3]-prevCoords[5]),
					prevCoords[4] + dist1*pnarray[0],
					prevCoords[5] + dist1*pnarray[1]
				    };
				    result1.curveTo(pcoords1[0], pcoords1[1],
						    pcoords1[2], pcoords1[3],
						    pcoords1[4], pcoords1[5]);
				    double pcoords2[] = {
					start1b.getX()+scale21*delta*tvector[0],
					start1b.getY()+scale21*delta*tvector[1],
					prevCoords[4] - dist2*pnarray[0]
					+ scale22*(prevCoords[2]-prevCoords[4]),
					prevCoords[5] - dist2*pnarray[1]
					+ scale22*(prevCoords[3]-prevCoords[5]),
					prevCoords[4] - dist2*pnarray[0],
					prevCoords[5] - dist2*pnarray[1]
				    };
				    result2.curveTo(pcoords2[0], pcoords2[1],
						    pcoords2[2], pcoords2[3],
						    pcoords2[4], pcoords2[5]);
				    double f = interpFactor(dist1, dist2,
							    dist3, true, ccw);
				    interpolate(pcoords1, pcoords2, pcoords3,
						f, true);
				    result3.curveTo(pcoords3[0], pcoords3[1],
						    pcoords3[2], pcoords3[3],
						    pcoords3[4], pcoords3[5]);
				} else if (sinAngle > 0.0) {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end1.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    double tmppcoords2[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					start2.getX() + narray0[0]*dist1
					+ nscale21*(coords[0]-start1.getX()),
					start2.getY() + narray0[1]*dist1
					+ nscale21*(coords[1]-start1.getY()),
					end2.getX() + narray1[0]*dist1
					+ nscale22*(coords[2]-end2.getX()),
					end2.getY() + narray1[1]*dist1
					+ nscale22*(coords[3]-end2.getY()),
					end2.getX() + narray1[0]*dist1,
					end2.getY() + narray1[1]*dist1
				    };
				    double[] ourxy
					= Path2DInfo.getSegmentIntersectionUVXY
					(PathIterator.SEG_CUBICTO,
					 start1a.getX(), start1a.getY(),
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() + narray0[0]*dist1,
					 start2.getY() + narray0[1]*dist1,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords2);
					result1.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result2.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double f = interpFactor(dist1, dist2,
								dist3, true,
								ccw);
					interpolate(newcoords1, newcoords2,
						    pcoords3, f, true);
					result3.curveTo(pcoords3[0],
							pcoords3[1],
							pcoords3[2],
							pcoords3[3],
							pcoords3[4],
							pcoords3[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3], newcoords2[4],
					     newcoords2[5], angle, maxDelta);
					result2.append(p, true);
					Point2D p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[2],
							      ourxy[3],
							      p3.getX(),
							      p3.getY(),
							      angle, maxDelta);
					result3.append(p, true);
				    } else {
				    }
				} else {
				    start1 = prevEntry.getStart();
				    end1 = prevEntry.getEnd();
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    Point2D start1a = result1.getCurrentPoint();
				    Point2D start1b = result2.getCurrentPoint();
				    double tmppcoords[] = {
					start1b.getX()
					+ scale21*(prevCoords[0]-start1.getX()),
					start1b.getY()
					+ scale21*(prevCoords[1]-start1.getY()),
					end1.getX() - pnarray[0]*dist2
					+ scale22*(prevCoords[2]-end1.getX()),
					end1.getY() - pnarray[1]*dist2
					+ scale22*(prevCoords[3]-end1.getY()),
					end1.getX() - pnarray[0]*dist2,
					end1.getY() - pnarray[1]*dist2
				    };
				    double tmppcoords2[] = {
					start1a.getX()
					+ scale11*(prevCoords[0]-start1.getX()),
					start1a.getY()
					+ scale11*(prevCoords[1]-start1.getY()),
					end1.getX() + pnarray[0]*dist1
					+ scale12*(prevCoords[2]-end1.getX()),
					end1.getY() + pnarray[1]*dist1
					+ scale12*(prevCoords[3]-end2.getY()),
					end1.getX() + pnarray[0]*dist1,
					end1.getY() + pnarray[1]*dist1
				    };
				    start2 = entry.getStart();
				    end2 = entry.getEnd();
				    double tmpcoords[] = {
					start2.getX() - narray0[0]*dist2
					+ nscale21*(coords[0]-start1.getX()),
					start2.getY() - narray0[1]*dist2
					+ nscale21*(coords[1]-start1.getY()),
					end2.getX() - narray1[0]*dist2
					+ nscale22*(coords[2]-end2.getX()),
					end2.getY() - narray1[1]*dist2
					+ nscale22*(coords[3]-end2.getY()),
					end2.getX() - narray1[0]*dist2,
					end2.getY() + narray1[1]*dist2
				    };
				    double[] ourxy
					= Path2DInfo.getSegmentIntersectionUVXY
					(PathIterator.SEG_CUBICTO,
					 start1b.getX(), start1b.getY(),
					 tmppcoords,
					 PathIterator.SEG_CUBICTO,
					 start2.getX() - narray0[0]*dist2,
					 start2.getY() - narray0[1]*dist2,
					 tmpcoords);
				    if (ourxy != null) {
					double s = ourxy[0];
					double[] newcoords1 = new double[6];
					PathSplitter.split(newcoords1, null,
							   s, 3,
							   start1b.getX(),
							   start1b.getY(),
							   tmppcoords);
					double[] newcoords2 = new double[6];
					PathSplitter.split(newcoords2, null,
							   s, 3,
							   start1a.getX(),
							   start1a.getY(),
							   tmppcoords2);
					result2.curveTo(newcoords1[0],
							newcoords1[1],
							newcoords1[2],
							newcoords1[3],
							newcoords1[4],
							newcoords1[5]);
					result1.curveTo(newcoords2[0],
							newcoords2[1],
							newcoords2[2],
							newcoords2[3],
							newcoords2[4],
							newcoords2[5]);
					double f = interpFactor(dist1, dist2,
								dist3, false,
								ccw);
					interpolate(newcoords2, newcoords1,
						    pcoords3, f, false);
					result3.curveTo(pcoords3[0],
							pcoords3[1],
							pcoords3[2],
							pcoords3[3],
							pcoords3[4],
							pcoords3[5]);
					double cosAngle = ptarray[0]*tarray0[0]
					    + ptarray[1]*tarray0[1];
					double angle =
					    Math.atan2(sinAngle,cosAngle);
					Path2D p = Paths2D.createArc
					    (ourxy[2], ourxy[3], newcoords2[4],
					     newcoords2[5], angle, maxDelta);
					result1.append(p, true);
					Point2D p3 = result3.getCurrentPoint();
					p = Paths2D.createArc(ourxy[2],
							      ourxy[3],
							      p3.getX(),
							      p3.getY(),
							      angle, maxDelta);
					result3.append(p, true);
				    } else {
				    }
				}
			    }
			    break;
			}
		    }
		}
		break;
	    case PathIterator.SEG_CLOSE:
		closed = true;
		sawMove = false;
		breakFromLoop = true;
		break;
	    }
	    if (breakFromLoop) break;
	    prevEntry = entry;
	    prevData = data;
	    prevType = type;
	    prevCoords = coords;
	    hasPrevNormal = hasNormal1;
	    if (hasPrevNormal) {
		System.arraycopy(narray1, 0, pnarray, 0, 2);
	    }
	    hasPrevTangent0 =  hasTangent0;
	    if (hasPrevTangent0) {
		System.arraycopy(tarray0, 0, ptarray0, 0, 2);
	    }
	    hasPrevTangent = hasTangent1;
	    if (hasPrevTangent) {
		System.arraycopy(tarray1, 0, ptarray, 0, 2);
	    }
	    hasPrevCurvature0 = hasCurvature0;
	    if (hasPrevCurvature0) {
		prevCurvature0 = curvature0;
	    }
	    hasPrevCurvature = hasCurvature1;
	    if (hasPrevCurvature) {
		prevCurvature = curvature1;
	    }
	}
	Point2D end = prevEntry.getEnd();

	switch(prevEntry.getType()) {
	case PathIterator.SEG_LINETO:
	    if (hasPrevNormal) {
		result1.lineTo(end.getX() + pnarray[0]*dist1,
			       end.getY() + pnarray[1]*dist1);
		result2.lineTo(end.getX() - pnarray[0]*dist2,
			       end.getY() - pnarray[1]*dist2);
		double f = interpFactor(dist1, dist2, dist3, true, ccw);
		Point2D p3 = interpolate(result1.getCurrentPoint(),
					 result2.getCurrentPoint(),
					 f, true);
		result3.lineTo(p3.getX(), p3.getY());
	    }
	    break;
	case PathIterator.SEG_CUBICTO:
	    if (hasPrevNormal) {
		double scale11 = 1.0 - prevCurvature0*dist1;
		double scale21 = 1.0 + prevCurvature0*dist2;
		double scale12 = 1.0 - prevCurvature*dist1;
		double scale22 = 1.0 + prevCurvature*dist2;
		Point2D start1 = prevEntry.getStart();
		Point2D end1 = prevEntry.getEnd();
		Point2D start1a = result1.getCurrentPoint();
		Point2D start1b = result2.getCurrentPoint();
		double nvector[] = {
		    start1a.getX() - start1b.getX(),
		    start1a.getY() - start1b.getY()
		};
		double nvectorNorm = Math.sqrt(nvector[0]*nvector[0]
					       + nvector[1]*nvector[1]);
		nvector[0] /= nvectorNorm;
		nvector[1] /= nvectorNorm;
		double tvector[] = {nvector[1], -nvector[0]};
		double deltax = prevCoords[0] - start1.getX();
		double deltay = prevCoords[1] - start1.getY();
		double delta = Math.sqrt(deltax*deltax + deltay*deltay);
		double pcoords1F[] = {
		    start1a.getX() + scale11*delta*tvector[0],
		    start1a.getY() + scale11*delta*tvector[1],
		    prevCoords[4] + dist1*pnarray[0]
		    +scale12*(prevCoords[2] - prevCoords[4]),
		    prevCoords[5] + dist1*pnarray[1]
		    +scale12*(prevCoords[3] - prevCoords[5]),
		    prevCoords[4] + dist1*pnarray[0],
		    prevCoords[5] + dist1*pnarray[1]
		};
		result1.curveTo(pcoords1F[0], pcoords1F[1], pcoords1F[2],
				pcoords1F[3], pcoords1F[4], pcoords1F[5]);
		double pcoords2F[] = {
		    start1b.getX() + scale21*delta*tvector[0],
		    start1b.getY() + scale21*delta*tvector[1],
		    prevCoords[4] - dist2*pnarray[0]
		    + scale22*(prevCoords[2] - prevCoords[4]),
		    prevCoords[5] - dist2*pnarray[1]
		    + scale22*(prevCoords[3] - prevCoords[5]),
		    prevCoords[4] - dist2*pnarray[0],
		    prevCoords[5] - dist2*pnarray[1]
		};
		result2.curveTo(pcoords2F[0], pcoords2F[1], pcoords2F[2],
				pcoords2F[3], pcoords2F[4], pcoords2F[5]);
		double f = interpFactor(dist1, dist2, dist3, true, ccw);
		interpolate(pcoords1F, pcoords2F, pcoords3, f, true);
		result3.curveTo(pcoords3[0], pcoords3[1], pcoords3[2],
				pcoords3[3], pcoords3[4], pcoords3[5]);

	    }
	}
	if (closed) result3.closePath();
	return result3;
    }
}

//  LocalWords:  exbundle xc yc Bezier Aleksas Riskus Giedrfia Liekus
//  LocalWords:  Informatyion Nr colinear ay eacute zier maxDelta nx
//  LocalWords:  IllegalArgumentException NullPointerException infin
//  LocalWords:  nullArg zeroLengthPath noTangent nullTangent boolean
//  LocalWords:  tangentLength tangentOffset collinear antiparallel
//  LocalWords:  DInfo getLineIntersectionUVXY ny noArcParallel tx ty
//  LocalWords:  noArcPossible createArc spath counterClockwise SEG
//  LocalWords:  affine PathIterator MOVETO offsetted lessThanZero
//  LocalWords:  offsetBy ccw isin
